{
  "version": "1.0",
  "timestamp": "2025-12-31T07:19:02.302076694+00:00",
  "actions": [
    {
      "action_id": "create_file_src/231_correction_plan_serializer.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "rename_file_/home/cicero-arch-omen/ai_sandbox/codex-agent/codex_sse/server-tools/MMSB/tools/mmsb-analyzer/src/005_refactor_constraints.rs_to_/home/cicero-arch-omen/ai_sandbox/codex-agent/codex_sse/server-tools/MMSB/tools/mmsb-analyzer/src/010_refactor_constraints.rs",
      "mutations": [
        {
          "type": "Rename",
          "from": "/home/cicero-arch-omen/ai_sandbox/codex-agent/codex_sse/server-tools/MMSB/tools/mmsb-analyzer/src/005_refactor_constraints.rs",
          "to": "/home/cicero-arch-omen/ai_sandbox/codex-agent/codex_sse/server-tools/MMSB/tools/mmsb-analyzer/src/010_refactor_constraints.rs",
          "original_content": "//! Refactoring constraints derived from invariants\n//!\n//! This module converts detected invariants into mechanical constraints that\n//! enforce safe refactorings. Constraints are machine-readable rules that\n//! determine what refactorings are allowed.\n\nuse crate::invariant_types::*;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// A constraint that restricts refactoring operations\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub enum RefactorConstraint {\n    /// Cannot move this item to a different file\n    NoMove {\n        target: String,\n        reason: String,\n        strength: InvariantStrength,\n    },\n\n    /// Cannot change the signature of this item\n    PreserveSignature {\n        target: String,\n        signature: String,\n        strength: InvariantStrength,\n    },\n\n    /// Cannot change the layer assignment\n    FixedLayer {\n        target: String,\n        layer: usize,\n        strength: InvariantStrength,\n    },\n\n    /// Must preserve ordering relative to other items\n    PreserveOrdering {\n        target: String,\n        must_come_before: Vec<String>,\n        strength: InvariantStrength,\n    },\n\n    /// Must preserve specific facts\n    MustPreserve {\n        target: String,\n        facts: Vec<String>,\n        strength: InvariantStrength,\n    },\n\n    /// Cannot delete this item (has critical dependencies)\n    NoDelete {\n        target: String,\n        dependents: Vec<String>,\n        strength: InvariantStrength,\n    },\n\n    /// Must maintain specific degree (in/out edges)\n    PreserveDegree {\n        target: String,\n        in_degree: usize,\n        out_degree: usize,\n        strength: InvariantStrength,\n    },\n}\n\nimpl fmt::Display for RefactorConstraint {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            RefactorConstraint::NoMove { target, reason, strength } => {\n                write!(f, \"[{}] NoMove: {} (reason: {})\", strength, target, reason)\n            }\n            RefactorConstraint::PreserveSignature { target, signature, strength } => {\n                write!(f, \"[{}] PreserveSignature: {} -> {}\", strength, target, signature)\n            }\n            RefactorConstraint::FixedLayer { target, layer, strength } => {\n                write!(f, \"[{}] FixedLayer: {} @ layer {}\", strength, target, layer)\n            }\n            RefactorConstraint::PreserveOrdering { target, must_come_before, strength } => {\n                write!(f, \"[{}] PreserveOrdering: {} before {:?}\", strength, target, must_come_before)\n            }\n            RefactorConstraint::MustPreserve { target, facts, strength } => {\n                write!(f, \"[{}] MustPreserve: {} -> {} facts\", strength, target, facts.len())\n            }\n            RefactorConstraint::NoDelete { target, dependents, strength } => {\n                write!(f, \"[{}] NoDelete: {} (dependents: {})\", strength, target, dependents.len())\n            }\n            RefactorConstraint::PreserveDegree { target, in_degree, out_degree, strength } => {\n                write!(f, \"[{}] PreserveDegree: {} (in={}, out={})\", strength, target, in_degree, out_degree)\n            }\n        }\n    }\n}\n\nimpl RefactorConstraint {\n    /// Get the target of this constraint\n    #[allow(dead_code)]\n    pub fn target(&self) -> &str {\n        match self {\n            RefactorConstraint::NoMove { target, .. } => target,\n            RefactorConstraint::PreserveSignature { target, .. } => target,\n            RefactorConstraint::FixedLayer { target, .. } => target,\n            RefactorConstraint::PreserveOrdering { target, .. } => target,\n            RefactorConstraint::MustPreserve { target, .. } => target,\n            RefactorConstraint::NoDelete { target, .. } => target,\n            RefactorConstraint::PreserveDegree { target, .. } => target,\n        }\n    }\n\n    /// Get the strength of the invariant backing this constraint\n    #[allow(dead_code)]\n    pub fn strength(&self) -> &InvariantStrength {\n        match self {\n            RefactorConstraint::NoMove { strength, .. } => strength,\n            RefactorConstraint::PreserveSignature { strength, .. } => strength,\n            RefactorConstraint::FixedLayer { strength, .. } => strength,\n            RefactorConstraint::PreserveOrdering { strength, .. } => strength,\n            RefactorConstraint::MustPreserve { strength, .. } => strength,\n            RefactorConstraint::NoDelete { strength, .. } => strength,\n            RefactorConstraint::PreserveDegree { strength, .. } => strength,\n        }\n    }\n\n    /// Check if this constraint should block a refactoring\n    #[allow(dead_code)]\n    pub fn is_blocking(&self) -> bool {\n        match self.strength() {\n            InvariantStrength::Proven => true,\n            InvariantStrength::Empirical { paths_checked } => *paths_checked >= 10,\n            InvariantStrength::Heuristic => false,\n        }\n    }\n}\n\n/// Convert an invariant to a refactoring constraint\npub fn from_invariant(invariant: &Invariant) -> Option<RefactorConstraint> {\n    match &invariant.kind {\n        InvariantKind::Structural(s) => match s {\n            StructuralInvariant::LayerFixed { layer } => Some(RefactorConstraint::FixedLayer {\n                target: invariant.target.clone(),\n                layer: *layer,\n                strength: invariant.strength,\n            }),\n            StructuralInvariant::DegreeStable { in_degree, out_degree } => {\n                Some(RefactorConstraint::PreserveDegree {\n                    target: invariant.target.clone(),\n                    in_degree: *in_degree,\n                    out_degree: *out_degree,\n                    strength: invariant.strength,\n                })\n            }\n            StructuralInvariant::Leaf | StructuralInvariant::Root => {\n                Some(RefactorConstraint::NoMove {\n                    target: invariant.target.clone(),\n                    reason: \"graph topology fixed\".to_string(),\n                    strength: invariant.strength,\n                })\n            }\n            StructuralInvariant::Bridge => Some(RefactorConstraint::NoDelete {\n                target: invariant.target.clone(),\n                dependents: vec![\"graph connectivity\".to_string()],\n                strength: invariant.strength,\n            }),\n            StructuralInvariant::SccMembership { .. } => Some(RefactorConstraint::NoMove {\n                target: invariant.target.clone(),\n                reason: \"SCC membership fixed\".to_string(),\n                strength: invariant.strength,\n            }),\n        },\n        InvariantKind::Semantic(s) => match s {\n            SemanticInvariant::TypeStable { signature } => {\n                Some(RefactorConstraint::PreserveSignature {\n                    target: invariant.target.clone(),\n                    signature: signature.clone(),\n                    strength: invariant.strength,\n                })\n            }\n            SemanticInvariant::PureFunction | SemanticInvariant::Idempotent => {\n                Some(RefactorConstraint::PreserveSignature {\n                    target: invariant.target.clone(),\n                    signature: \"effects must remain pure\".to_string(),\n                    strength: invariant.strength,\n                })\n            }\n            SemanticInvariant::EffectStable { .. } => Some(RefactorConstraint::PreserveSignature {\n                target: invariant.target.clone(),\n                signature: \"effect signature fixed\".to_string(),\n                strength: invariant.strength,\n            }),\n        },\n        InvariantKind::Delta(d) => match d {\n            DeltaInvariant::Monotonic { .. } => Some(RefactorConstraint::PreserveOrdering {\n                target: invariant.target.clone(),\n                must_come_before: Vec::new(),\n                strength: invariant.strength,\n            }),\n            _ => None, // Other delta invariants don't directly map to refactor constraints\n        },\n        InvariantKind::PathIntersection(p) => Some(RefactorConstraint::MustPreserve {\n            target: invariant.target.clone(),\n            facts: p.facts.iter().cloned().collect(),\n            strength: invariant.strength,\n        }),\n    }\n}\n\n/// Check if a move operation is allowed by constraints\n#[allow(dead_code)]\npub fn check_move_allowed(\n    target: &str,\n    current_file: &str,\n    suggested_file: &str,\n    constraints: &[RefactorConstraint],\n) -> Result<(), String> {\n    for constraint in constraints {\n        if constraint.target() == target && constraint.is_blocking() {\n            match constraint {\n                RefactorConstraint::NoMove { reason, .. } => {\n                    return Err(format!(\n                        \"Cannot move {} from {} to {}: {}\",\n                        target, current_file, suggested_file, reason\n                    ));\n                }\n                RefactorConstraint::FixedLayer { layer, .. } => {\n                    return Err(format!(\n                        \"Cannot move {} from {} to {}: layer {} is fixed\",\n                        target, current_file, suggested_file, layer\n                    ));\n                }\n                _ => {} // Other constraints don't block moves\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Generate all constraints from an invariant analysis result\npub fn generate_constraints(analysis: &InvariantAnalysisResult) -> Vec<RefactorConstraint> {\n    analysis\n        .invariants\n        .iter()\n        .filter_map(from_invariant)\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashSet;\n\n    #[test]\n    fn test_from_invariant_layer_fixed() {\n        let inv = Invariant::new(\n            \"test_fn\".to_string(),\n            \"test.rs\".to_string(),\n            InvariantKind::Structural(StructuralInvariant::LayerFixed { layer: 5 }),\n            InvariantStrength::Proven,\n            \"Layer is fixed\".to_string(),\n        );\n\n        let constraint = from_invariant(&inv).unwrap();\n        match constraint {\n            RefactorConstraint::FixedLayer { target, layer, .. } => {\n                assert_eq!(target, \"test_fn\");\n                assert_eq!(layer, 5);\n            }\n            _ => panic!(\"Wrong constraint type\"),\n        }\n    }\n\n    #[test]\n    fn test_check_move_allowed_blocking() {\n        let constraints = vec![RefactorConstraint::NoMove {\n            target: \"test_fn\".to_string(),\n            reason: \"layer fixed\".to_string(),\n            strength: InvariantStrength::Proven,\n        }];\n\n        let result = check_move_allowed(\"test_fn\", \"old.rs\", \"new.rs\", &constraints);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"layer fixed\"));\n    }\n\n    #[test]\n    fn test_check_move_allowed_non_blocking() {\n        let constraints = vec![RefactorConstraint::NoMove {\n            target: \"test_fn\".to_string(),\n            reason: \"heuristic\".to_string(),\n            strength: InvariantStrength::Heuristic,\n        }];\n\n        let result = check_move_allowed(\"test_fn\", \"old.rs\", \"new.rs\", &constraints);\n        assert!(result.is_ok()); // Heuristics don't block\n    }\n\n    #[test]\n    fn test_constraint_is_blocking() {\n        let proven = RefactorConstraint::NoMove {\n            target: \"fn1\".to_string(),\n            reason: \"test\".to_string(),\n            strength: InvariantStrength::Proven,\n        };\n        assert!(proven.is_blocking());\n\n        let heuristic = RefactorConstraint::NoMove {\n            target: \"fn2\".to_string(),\n            reason: \"test\".to_string(),\n            strength: InvariantStrength::Heuristic,\n        };\n        assert!(!heuristic.is_blocking());\n    }\n}\n",
          "updated_content": null
        }
      ],
      "applied": false,
      "errors": []
    }
  ]
}