{
  "version": "1.0",
  "timestamp": "2025-12-31T07:10:25.040542502+00:00",
  "actions": [
    {
      "action_id": "move_detect_test_modules_to_src/211_dead_code_attribute_parser.rs",
      "mutations": [
        {
          "type": "FileEdit",
          "path": "/home/cicero-arch-omen/ai_sandbox/codex-agent/codex_sse/server-tools/MMSB/tools/mmsb-analyzer/src/215_dead_code_test_boundaries.rs",
          "original_content": "#![allow(dead_code)]\n//! Test boundary detection for dead code classification.\n\nuse crate::dead_code_attribute_parser::is_cfg_test_item;\nuse crate::dead_code_call_graph::{build_reverse_call_graph, CallGraph};\nuse std::collections::{HashSet, VecDeque};\nuse std::path::{Path, PathBuf};\nuse syn::{Attribute, Item};\n\n#[derive(Debug, Clone, Default)]\npub struct TestBoundaries {\n    pub test_modules: HashSet<String>,\n    pub test_symbols: HashSet<String>,\n    pub test_files: HashSet<PathBuf>,\n}\n\npub fn detect_test_modules(file: &Path) -> HashSet<String> {\n    let contents = std::fs::read_to_string(file).unwrap_or_default();\n    let parsed = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return HashSet::new(),\n    };\n    let mut modules = HashSet::new();\n    for item in &parsed.items {\n        if let Item::Mod(item_mod) = item {\n            if is_cfg_test_item(item) {\n                modules.insert(item_mod.ident.to_string());\n            }\n        }\n    }\n    modules\n}\n\npub fn detect_test_symbols(file: &Path) -> HashSet<String> {\n    let contents = std::fs::read_to_string(file).unwrap_or_default();\n    let parsed = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return HashSet::new(),\n    };\n    let mut symbols = HashSet::new();\n    for item in &parsed.items {\n        if let Item::Fn(item_fn) = item {\n            if has_test_attr(&item_fn.attrs) {\n                symbols.insert(item_fn.sig.ident.to_string());\n            }\n        }\n        if let Item::Mod(item_mod) = item {\n            if is_cfg_test_item(item) {\n                symbols.insert(item_mod.ident.to_string());\n                if let Some((_, items)) = &item_mod.content {\n                    for nested in items {\n                        if let Item::Fn(nested_fn) = nested {\n                            symbols.insert(nested_fn.sig.ident.to_string());\n                        }\n                    }\n                }\n            }\n        }\n    }\n    symbols\n}\n\n\n\npub fn find_test_callers(\n    symbol: &str,\n    call_graph: &CallGraph,\n    test_symbols: &HashSet<String>,\n) -> Vec<String> {\n    if test_symbols.is_empty() {\n        return Vec::new();\n    }\n    let reverse = build_reverse_call_graph(call_graph);\n    let mut callers = Vec::new();\n    let mut visited = HashSet::new();\n    let mut queue: VecDeque<String> = reverse\n        .get(symbol)\n        .cloned()\n        .unwrap_or_default()\n        .into_iter()\n        .collect();\n\n    while let Some(caller) = queue.pop_front() {\n        if !visited.insert(caller.clone()) {\n            continue;\n        }\n        if test_symbols.contains(&caller) {\n            callers.push(caller.clone());\n        }\n        if let Some(next) = reverse.get(&caller) {\n            for parent in next {\n                if !visited.contains(parent) {\n                    queue.push_back(parent.clone());\n                }\n            }\n        }\n    }\n\n    callers\n}\n\nfn has_test_attr(attrs: &[Attribute]) -> bool {\n    attrs.iter().any(|attr| {\n        let path = attr.path();\n        if path.is_ident(\"test\") {\n            return true;\n        }\n        let last = path.segments.last().map(|seg| seg.ident.to_string());\n        matches!(last.as_deref(), Some(\"test\"))\n    })\n}\n\nfn item_attrs(item: &Item) -> &[Attribute] {\n    match item {\n        Item::Fn(item_fn) => &item_fn.attrs,\n        Item::Struct(item_struct) => &item_struct.attrs,\n        Item::Enum(item_enum) => &item_enum.attrs,\n        Item::Mod(item_mod) => &item_mod.attrs,\n        Item::Trait(item_trait) => &item_trait.attrs,\n        _ => &[],\n    }\n}\n",
          "updated_content": null
        },
        {
          "type": "FileEdit",
          "path": "/home/cicero-arch-omen/ai_sandbox/codex-agent/codex_sse/server-tools/MMSB/tools/mmsb-analyzer/src/211_dead_code_attribute_parser.rs",
          "original_content": "#![allow(dead_code)]\n//! Attribute parsing for dead code intent markers.\n\nuse crate::dead_code_doc_comment_parser::{extract_doc_markers, merge_doc_intent};\nuse crate::dead_code_intent::{\n    check_planned_directory, collect_symbols, merge_intent_sources, planned_directory_intent,\n    DeadCodePolicy,\n};\nuse crate::dead_code_types::{IntentMap, IntentMarker, IntentMetadata, IntentSource, IntentTag};\nuse std::collections::HashMap;\nuse std::path::Path;\nuse syn::{Attribute, Item};\n\npub fn parse_mmsb_latent_attr(path: &Path) -> HashMap<String, Vec<IntentMetadata>> {\n    let contents = std::fs::read_to_string(path).unwrap_or_default();\n    let file = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return HashMap::new(),\n    };\n    let mut map: HashMap<String, Vec<IntentMetadata>> = HashMap::new();\n    for item in &file.items {\n        let Some(name) = item_name(item) else {\n            continue;\n        };\n        let tags = collect_latent_attrs(item_attrs(item));\n        if tags.is_empty() {\n            continue;\n        }\n        map.entry(name).or_default().extend(tags);\n    }\n    map\n}\n\npub fn scan_file_attributes(path: &Path) -> Vec<IntentTag> {\n    let contents = std::fs::read_to_string(path).unwrap_or_default();\n    let file = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return Vec::new(),\n    };\n    let mut tags = Vec::new();\n    for item in &file.items {\n        let Some(symbol) = item_name(item) else {\n            continue;\n        };\n        for meta in collect_latent_attrs(item_attrs(item)) {\n            tags.push(IntentTag {\n                symbol: symbol.clone(),\n                file: path.to_path_buf(),\n                line: None,\n                marker: meta.marker,\n                source: meta.source,\n                value: meta.value.clone(),\n            });\n        }\n    }\n    tags\n}\n\npub fn extract_attribute_value(attr: &Attribute, key: &str) -> Option<String> {\n    let mut found = None;\n    let _ = attr.parse_nested_meta(|meta| {\n        if meta.path.is_ident(key) {\n            let value = meta.value()?;\n            let lit: syn::LitStr = value.parse()?;\n            found = Some(lit.value());\n        }\n        Ok(())\n    });\n    found\n}\n\nfn collect_latent_attrs(attrs: &[Attribute]) -> Vec<IntentMetadata> {\n    let mut markers = Vec::new();\n    for attr in attrs {\n        if !attr.path().is_ident(\"mmsb_latent\") {\n            continue;\n        }\n        let mut marker = IntentMarker::Latent;\n        let mut value = None;\n        let mut saw_nested = false;\n        let _ = attr.parse_nested_meta(|meta| {\n            saw_nested = true;\n            if meta.path.is_ident(\"planned\") {\n                marker = IntentMarker::Planned;\n            } else if meta.path.is_ident(\"future\") {\n                marker = IntentMarker::Future;\n            } else if meta.path.is_ident(\"deprecated_planned\")\n                || meta.path.is_ident(\"deprecated-planned\")\n            {\n                marker = IntentMarker::DeprecatedPlanned;\n            } else if meta.path.is_ident(\"reason\") || meta.path.is_ident(\"note\") {\n                let value_meta = meta.value()?;\n                let lit: syn::LitStr = value_meta.parse()?;\n                value = Some(lit.value());\n            } else if meta.path.is_ident(\"marker\") {\n                let value_meta = meta.value()?;\n                let lit: syn::LitStr = value_meta.parse()?;\n                marker = marker_from_str(&lit.value());\n            }\n            Ok(())\n        });\n        if !saw_nested {\n            if let Ok(lit) = attr.parse_args::<syn::LitStr>() {\n                value = Some(lit.value());\n            }\n        }\n\n        markers.push(IntentMetadata {\n            marker,\n            source: IntentSource::Attribute,\n            value,\n        });\n    }\n    markers\n}\n\nfn marker_from_str(raw: &str) -> IntentMarker {\n    match raw.to_ascii_lowercase().as_str() {\n        \"planned\" => IntentMarker::Planned,\n        \"future\" => IntentMarker::Future,\n        \"deprecated_planned\" | \"deprecated-planned\" => IntentMarker::DeprecatedPlanned,\n        _ => IntentMarker::Latent,\n    }\n}\n\nfn item_name(item: &Item) -> Option<String> {\n    match item {\n        Item::Fn(item_fn) => Some(item_fn.sig.ident.to_string()),\n        Item::Struct(item_struct) => Some(item_struct.ident.to_string()),\n        Item::Enum(item_enum) => Some(item_enum.ident.to_string()),\n        Item::Mod(item_mod) => Some(item_mod.ident.to_string()),\n        Item::Trait(item_trait) => Some(item_trait.ident.to_string()),\n        _ => None,\n    }\n}\n\nfn item_attrs(item: &Item) -> &[Attribute] {\n    match item {\n        Item::Fn(item_fn) => &item_fn.attrs,\n        Item::Struct(item_struct) => &item_struct.attrs,\n        Item::Enum(item_enum) => &item_enum.attrs,\n        Item::Mod(item_mod) => &item_mod.attrs,\n        Item::Trait(item_trait) => &item_trait.attrs,\n        _ => &[],\n    }\n}\n\npub fn scan_doc_comments(file: &Path) -> HashMap<String, Vec<IntentMarker>> {\n    let contents = std::fs::read_to_string(file).unwrap_or_default();\n    let parsed = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return HashMap::new(),\n    };\n    let mut map: HashMap<String, Vec<IntentMarker>> = HashMap::new();\n    for item in &parsed.items {\n        let Some(symbol) = item_name(item) else {\n            continue;\n        };\n        let markers = extract_doc_markers(item_attrs(item));\n        if markers.is_empty() {\n            continue;\n        }\n        map.entry(symbol).or_default().extend(markers);\n    }\n    map\n}\n\npub fn detect_intent_signals(file: &Path, policy: Option<&DeadCodePolicy>) -> IntentMap {\n    let attrs = parse_mmsb_latent_attr(file);\n    let doc_map = scan_doc_comments(file);\n    let docs = merge_doc_intent(doc_map);\n    let dir_map = planned_directory_intent(file, policy);\n    merge_intent_sources(attrs, docs, dir_map)\n}\n\npub fn scan_intent_tags(file: &Path, policy: Option<&DeadCodePolicy>) -> Vec<IntentTag> {\n    let mut tags = Vec::new();\n    let attrs = parse_mmsb_latent_attr(file);\n    for (symbol, items) in attrs {\n        for meta in items {\n            tags.push(IntentTag {\n                symbol: symbol.clone(),\n                file: file.to_path_buf(),\n                line: None,\n                marker: meta.marker,\n                source: meta.source,\n                value: meta.value.clone(),\n            });\n        }\n    }\n\n    let doc_map = scan_doc_comments(file);\n    for (symbol, markers) in doc_map {\n        for marker in markers {\n            tags.push(IntentTag {\n                symbol: symbol.clone(),\n                file: file.to_path_buf(),\n                line: None,\n                marker,\n                source: IntentSource::DocComment,\n                value: None,\n            });\n        }\n    }\n\n    if check_planned_directory(file, policy) {\n        for symbol in collect_symbols(file) {\n            tags.push(IntentTag {\n                symbol,\n                file: file.to_path_buf(),\n                line: None,\n                marker: IntentMarker::Planned,\n                source: IntentSource::Directory,\n                value: None,\n            });\n        }\n    }\n\n    tags\n}\n\npub fn is_cfg_test_item(item: &Item) -> bool {\n    item_attrs(item).iter().any(|attr| {\n        if !attr.path().is_ident(\"cfg\") {\n            return false;\n        }\n        let mut found = false;\n        let _ = attr.parse_nested_meta(|meta| {\n            if meta.path.is_ident(\"test\") {\n                found = true;\n                return Ok(());\n            }\n            if meta.path.is_ident(\"any\") {\n                meta.parse_nested_meta(|nested| {\n                    if nested.path.is_ident(\"test\") {\n                        found = true;\n                    }\n                    Ok(())\n                })?;\n            }\n            Ok(())\n        });\n        found\n    })\n}\n",
          "updated_content": "#![allow(dead_code)]\nuse crate::dead_code_attribute_parser::is_cfg_test_item;\nuse std::collections::HashSet;\n//! Attribute parsing for dead code intent markers.\n\nuse crate::dead_code_doc_comment_parser::{extract_doc_markers, merge_doc_intent};\nuse crate::dead_code_intent::{\n    check_planned_directory, collect_symbols, merge_intent_sources, planned_directory_intent,\n    DeadCodePolicy,\n};\nuse crate::dead_code_types::{IntentMap, IntentMarker, IntentMetadata, IntentSource, IntentTag};\nuse std::collections::HashMap;\nuse std::path::Path;\nuse syn::{Attribute, Item};\n\npub fn parse_mmsb_latent_attr(path: &Path) -> HashMap<String, Vec<IntentMetadata>> {\n    let contents = std::fs::read_to_string(path).unwrap_or_default();\n    let file = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return HashMap::new(),\n    };\n    let mut map: HashMap<String, Vec<IntentMetadata>> = HashMap::new();\n    for item in &file.items {\n        let Some(name) = item_name(item) else {\n            continue;\n        };\n        let tags = collect_latent_attrs(item_attrs(item));\n        if tags.is_empty() {\n            continue;\n        }\n        map.entry(name).or_default().extend(tags);\n    }\n    map\n}\n\npub fn scan_file_attributes(path: &Path) -> Vec<IntentTag> {\n    let contents = std::fs::read_to_string(path).unwrap_or_default();\n    let file = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return Vec::new(),\n    };\n    let mut tags = Vec::new();\n    for item in &file.items {\n        let Some(symbol) = item_name(item) else {\n            continue;\n        };\n        for meta in collect_latent_attrs(item_attrs(item)) {\n            tags.push(IntentTag {\n                symbol: symbol.clone(),\n                file: path.to_path_buf(),\n                line: None,\n                marker: meta.marker,\n                source: meta.source,\n                value: meta.value.clone(),\n            });\n        }\n    }\n    tags\n}\n\npub fn extract_attribute_value(attr: &Attribute, key: &str) -> Option<String> {\n    let mut found = None;\n    let _ = attr.parse_nested_meta(|meta| {\n        if meta.path.is_ident(key) {\n            let value = meta.value()?;\n            let lit: syn::LitStr = value.parse()?;\n            found = Some(lit.value());\n        }\n        Ok(())\n    });\n    found\n}\n\nfn collect_latent_attrs(attrs: &[Attribute]) -> Vec<IntentMetadata> {\n    let mut markers = Vec::new();\n    for attr in attrs {\n        if !attr.path().is_ident(\"mmsb_latent\") {\n            continue;\n        }\n        let mut marker = IntentMarker::Latent;\n        let mut value = None;\n        let mut saw_nested = false;\n        let _ = attr.parse_nested_meta(|meta| {\n            saw_nested = true;\n            if meta.path.is_ident(\"planned\") {\n                marker = IntentMarker::Planned;\n            } else if meta.path.is_ident(\"future\") {\n                marker = IntentMarker::Future;\n            } else if meta.path.is_ident(\"deprecated_planned\")\n                || meta.path.is_ident(\"deprecated-planned\")\n            {\n                marker = IntentMarker::DeprecatedPlanned;\n            } else if meta.path.is_ident(\"reason\") || meta.path.is_ident(\"note\") {\n                let value_meta = meta.value()?;\n                let lit: syn::LitStr = value_meta.parse()?;\n                value = Some(lit.value());\n            } else if meta.path.is_ident(\"marker\") {\n                let value_meta = meta.value()?;\n                let lit: syn::LitStr = value_meta.parse()?;\n                marker = marker_from_str(&lit.value());\n            }\n            Ok(())\n        });\n        if !saw_nested {\n            if let Ok(lit) = attr.parse_args::<syn::LitStr>() {\n                value = Some(lit.value());\n            }\n        }\n\n        markers.push(IntentMetadata {\n            marker,\n            source: IntentSource::Attribute,\n            value,\n        });\n    }\n    markers\n}\n\nfn marker_from_str(raw: &str) -> IntentMarker {\n    match raw.to_ascii_lowercase().as_str() {\n        \"planned\" => IntentMarker::Planned,\n        \"future\" => IntentMarker::Future,\n        \"deprecated_planned\" | \"deprecated-planned\" => IntentMarker::DeprecatedPlanned,\n        _ => IntentMarker::Latent,\n    }\n}\n\nfn item_name(item: &Item) -> Option<String> {\n    match item {\n        Item::Fn(item_fn) => Some(item_fn.sig.ident.to_string()),\n        Item::Struct(item_struct) => Some(item_struct.ident.to_string()),\n        Item::Enum(item_enum) => Some(item_enum.ident.to_string()),\n        Item::Mod(item_mod) => Some(item_mod.ident.to_string()),\n        Item::Trait(item_trait) => Some(item_trait.ident.to_string()),\n        _ => None,\n    }\n}\n\nfn item_attrs(item: &Item) -> &[Attribute] {\n    match item {\n        Item::Fn(item_fn) => &item_fn.attrs,\n        Item::Struct(item_struct) => &item_struct.attrs,\n        Item::Enum(item_enum) => &item_enum.attrs,\n        Item::Mod(item_mod) => &item_mod.attrs,\n        Item::Trait(item_trait) => &item_trait.attrs,\n        _ => &[],\n    }\n}\n\npub fn scan_doc_comments(file: &Path) -> HashMap<String, Vec<IntentMarker>> {\n    let contents = std::fs::read_to_string(file).unwrap_or_default();\n    let parsed = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return HashMap::new(),\n    };\n    let mut map: HashMap<String, Vec<IntentMarker>> = HashMap::new();\n    for item in &parsed.items {\n        let Some(symbol) = item_name(item) else {\n            continue;\n        };\n        let markers = extract_doc_markers(item_attrs(item));\n        if markers.is_empty() {\n            continue;\n        }\n        map.entry(symbol).or_default().extend(markers);\n    }\n    map\n}\n\npub fn detect_intent_signals(file: &Path, policy: Option<&DeadCodePolicy>) -> IntentMap {\n    let attrs = parse_mmsb_latent_attr(file);\n    let doc_map = scan_doc_comments(file);\n    let docs = merge_doc_intent(doc_map);\n    let dir_map = planned_directory_intent(file, policy);\n    merge_intent_sources(attrs, docs, dir_map)\n}\n\npub fn scan_intent_tags(file: &Path, policy: Option<&DeadCodePolicy>) -> Vec<IntentTag> {\n    let mut tags = Vec::new();\n    let attrs = parse_mmsb_latent_attr(file);\n    for (symbol, items) in attrs {\n        for meta in items {\n            tags.push(IntentTag {\n                symbol: symbol.clone(),\n                file: file.to_path_buf(),\n                line: None,\n                marker: meta.marker,\n                source: meta.source,\n                value: meta.value.clone(),\n            });\n        }\n    }\n\n    let doc_map = scan_doc_comments(file);\n    for (symbol, markers) in doc_map {\n        for marker in markers {\n            tags.push(IntentTag {\n                symbol: symbol.clone(),\n                file: file.to_path_buf(),\n                line: None,\n                marker,\n                source: IntentSource::DocComment,\n                value: None,\n            });\n        }\n    }\n\n    if check_planned_directory(file, policy) {\n        for symbol in collect_symbols(file) {\n            tags.push(IntentTag {\n                symbol,\n                file: file.to_path_buf(),\n                line: None,\n                marker: IntentMarker::Planned,\n                source: IntentSource::Directory,\n                value: None,\n            });\n        }\n    }\n\n    tags\n}\n\npub fn is_cfg_test_item(item: &Item) -> bool {\n    item_attrs(item).iter().any(|attr| {\n        if !attr.path().is_ident(\"cfg\") {\n            return false;\n        }\n        let mut found = false;\n        let _ = attr.parse_nested_meta(|meta| {\n            if meta.path.is_ident(\"test\") {\n                found = true;\n                return Ok(());\n            }\n            if meta.path.is_ident(\"any\") {\n                meta.parse_nested_meta(|nested| {\n                    if nested.path.is_ident(\"test\") {\n                        found = true;\n                    }\n                    Ok(())\n                })?;\n            }\n            Ok(())\n        });\n        found\n    })\n}\n\npub fn detect_test_modules(file: &Path) -> HashSet<String> {\n    let contents = std::fs::read_to_string(file).unwrap_or_default();\n    let parsed = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return HashSet::new(),\n    };\n    let mut modules = HashSet::new();\n    for item in &parsed.items {\n        if let Item::Mod(item_mod) = item {\n            if is_cfg_test_item(item) {\n                modules.insert(item_mod.ident.to_string());\n            }\n        }\n    }\n    modules\n}\n"
        }
      ],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_detect_test_symbols_to_src/211_dead_code_attribute_parser.rs",
      "mutations": [
        {
          "type": "FileEdit",
          "path": "/home/cicero-arch-omen/ai_sandbox/codex-agent/codex_sse/server-tools/MMSB/tools/mmsb-analyzer/src/215_dead_code_test_boundaries.rs",
          "original_content": "#![allow(dead_code)]\n//! Test boundary detection for dead code classification.\n\nuse crate::dead_code_attribute_parser::is_cfg_test_item;\nuse crate::dead_code_call_graph::{build_reverse_call_graph, CallGraph};\nuse std::collections::{HashSet, VecDeque};\nuse std::path::{Path, PathBuf};\nuse syn::{Attribute, Item};\n\n#[derive(Debug, Clone, Default)]\npub struct TestBoundaries {\n    pub test_modules: HashSet<String>,\n    pub test_symbols: HashSet<String>,\n    pub test_files: HashSet<PathBuf>,\n}\n\n\n\npub fn detect_test_symbols(file: &Path) -> HashSet<String> {\n    let contents = std::fs::read_to_string(file).unwrap_or_default();\n    let parsed = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return HashSet::new(),\n    };\n    let mut symbols = HashSet::new();\n    for item in &parsed.items {\n        if let Item::Fn(item_fn) = item {\n            if has_test_attr(&item_fn.attrs) {\n                symbols.insert(item_fn.sig.ident.to_string());\n            }\n        }\n        if let Item::Mod(item_mod) = item {\n            if is_cfg_test_item(item) {\n                symbols.insert(item_mod.ident.to_string());\n                if let Some((_, items)) = &item_mod.content {\n                    for nested in items {\n                        if let Item::Fn(nested_fn) = nested {\n                            symbols.insert(nested_fn.sig.ident.to_string());\n                        }\n                    }\n                }\n            }\n        }\n    }\n    symbols\n}\n\n\n\npub fn find_test_callers(\n    symbol: &str,\n    call_graph: &CallGraph,\n    test_symbols: &HashSet<String>,\n) -> Vec<String> {\n    if test_symbols.is_empty() {\n        return Vec::new();\n    }\n    let reverse = build_reverse_call_graph(call_graph);\n    let mut callers = Vec::new();\n    let mut visited = HashSet::new();\n    let mut queue: VecDeque<String> = reverse\n        .get(symbol)\n        .cloned()\n        .unwrap_or_default()\n        .into_iter()\n        .collect();\n\n    while let Some(caller) = queue.pop_front() {\n        if !visited.insert(caller.clone()) {\n            continue;\n        }\n        if test_symbols.contains(&caller) {\n            callers.push(caller.clone());\n        }\n        if let Some(next) = reverse.get(&caller) {\n            for parent in next {\n                if !visited.contains(parent) {\n                    queue.push_back(parent.clone());\n                }\n            }\n        }\n    }\n\n    callers\n}\n\nfn has_test_attr(attrs: &[Attribute]) -> bool {\n    attrs.iter().any(|attr| {\n        let path = attr.path();\n        if path.is_ident(\"test\") {\n            return true;\n        }\n        let last = path.segments.last().map(|seg| seg.ident.to_string());\n        matches!(last.as_deref(), Some(\"test\"))\n    })\n}\n\nfn item_attrs(item: &Item) -> &[Attribute] {\n    match item {\n        Item::Fn(item_fn) => &item_fn.attrs,\n        Item::Struct(item_struct) => &item_struct.attrs,\n        Item::Enum(item_enum) => &item_enum.attrs,\n        Item::Mod(item_mod) => &item_mod.attrs,\n        Item::Trait(item_trait) => &item_trait.attrs,\n        _ => &[],\n    }\n}\n",
          "updated_content": null
        },
        {
          "type": "FileEdit",
          "path": "/home/cicero-arch-omen/ai_sandbox/codex-agent/codex_sse/server-tools/MMSB/tools/mmsb-analyzer/src/211_dead_code_attribute_parser.rs",
          "original_content": "#![allow(dead_code)]\nuse crate::dead_code_attribute_parser::is_cfg_test_item;\nuse std::collections::HashSet;\n//! Attribute parsing for dead code intent markers.\n\nuse crate::dead_code_doc_comment_parser::{extract_doc_markers, merge_doc_intent};\nuse crate::dead_code_intent::{\n    check_planned_directory, collect_symbols, merge_intent_sources, planned_directory_intent,\n    DeadCodePolicy,\n};\nuse crate::dead_code_types::{IntentMap, IntentMarker, IntentMetadata, IntentSource, IntentTag};\nuse std::collections::HashMap;\nuse std::path::Path;\nuse syn::{Attribute, Item};\n\npub fn parse_mmsb_latent_attr(path: &Path) -> HashMap<String, Vec<IntentMetadata>> {\n    let contents = std::fs::read_to_string(path).unwrap_or_default();\n    let file = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return HashMap::new(),\n    };\n    let mut map: HashMap<String, Vec<IntentMetadata>> = HashMap::new();\n    for item in &file.items {\n        let Some(name) = item_name(item) else {\n            continue;\n        };\n        let tags = collect_latent_attrs(item_attrs(item));\n        if tags.is_empty() {\n            continue;\n        }\n        map.entry(name).or_default().extend(tags);\n    }\n    map\n}\n\npub fn scan_file_attributes(path: &Path) -> Vec<IntentTag> {\n    let contents = std::fs::read_to_string(path).unwrap_or_default();\n    let file = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return Vec::new(),\n    };\n    let mut tags = Vec::new();\n    for item in &file.items {\n        let Some(symbol) = item_name(item) else {\n            continue;\n        };\n        for meta in collect_latent_attrs(item_attrs(item)) {\n            tags.push(IntentTag {\n                symbol: symbol.clone(),\n                file: path.to_path_buf(),\n                line: None,\n                marker: meta.marker,\n                source: meta.source,\n                value: meta.value.clone(),\n            });\n        }\n    }\n    tags\n}\n\npub fn extract_attribute_value(attr: &Attribute, key: &str) -> Option<String> {\n    let mut found = None;\n    let _ = attr.parse_nested_meta(|meta| {\n        if meta.path.is_ident(key) {\n            let value = meta.value()?;\n            let lit: syn::LitStr = value.parse()?;\n            found = Some(lit.value());\n        }\n        Ok(())\n    });\n    found\n}\n\nfn collect_latent_attrs(attrs: &[Attribute]) -> Vec<IntentMetadata> {\n    let mut markers = Vec::new();\n    for attr in attrs {\n        if !attr.path().is_ident(\"mmsb_latent\") {\n            continue;\n        }\n        let mut marker = IntentMarker::Latent;\n        let mut value = None;\n        let mut saw_nested = false;\n        let _ = attr.parse_nested_meta(|meta| {\n            saw_nested = true;\n            if meta.path.is_ident(\"planned\") {\n                marker = IntentMarker::Planned;\n            } else if meta.path.is_ident(\"future\") {\n                marker = IntentMarker::Future;\n            } else if meta.path.is_ident(\"deprecated_planned\")\n                || meta.path.is_ident(\"deprecated-planned\")\n            {\n                marker = IntentMarker::DeprecatedPlanned;\n            } else if meta.path.is_ident(\"reason\") || meta.path.is_ident(\"note\") {\n                let value_meta = meta.value()?;\n                let lit: syn::LitStr = value_meta.parse()?;\n                value = Some(lit.value());\n            } else if meta.path.is_ident(\"marker\") {\n                let value_meta = meta.value()?;\n                let lit: syn::LitStr = value_meta.parse()?;\n                marker = marker_from_str(&lit.value());\n            }\n            Ok(())\n        });\n        if !saw_nested {\n            if let Ok(lit) = attr.parse_args::<syn::LitStr>() {\n                value = Some(lit.value());\n            }\n        }\n\n        markers.push(IntentMetadata {\n            marker,\n            source: IntentSource::Attribute,\n            value,\n        });\n    }\n    markers\n}\n\nfn marker_from_str(raw: &str) -> IntentMarker {\n    match raw.to_ascii_lowercase().as_str() {\n        \"planned\" => IntentMarker::Planned,\n        \"future\" => IntentMarker::Future,\n        \"deprecated_planned\" | \"deprecated-planned\" => IntentMarker::DeprecatedPlanned,\n        _ => IntentMarker::Latent,\n    }\n}\n\nfn item_name(item: &Item) -> Option<String> {\n    match item {\n        Item::Fn(item_fn) => Some(item_fn.sig.ident.to_string()),\n        Item::Struct(item_struct) => Some(item_struct.ident.to_string()),\n        Item::Enum(item_enum) => Some(item_enum.ident.to_string()),\n        Item::Mod(item_mod) => Some(item_mod.ident.to_string()),\n        Item::Trait(item_trait) => Some(item_trait.ident.to_string()),\n        _ => None,\n    }\n}\n\nfn item_attrs(item: &Item) -> &[Attribute] {\n    match item {\n        Item::Fn(item_fn) => &item_fn.attrs,\n        Item::Struct(item_struct) => &item_struct.attrs,\n        Item::Enum(item_enum) => &item_enum.attrs,\n        Item::Mod(item_mod) => &item_mod.attrs,\n        Item::Trait(item_trait) => &item_trait.attrs,\n        _ => &[],\n    }\n}\n\npub fn scan_doc_comments(file: &Path) -> HashMap<String, Vec<IntentMarker>> {\n    let contents = std::fs::read_to_string(file).unwrap_or_default();\n    let parsed = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return HashMap::new(),\n    };\n    let mut map: HashMap<String, Vec<IntentMarker>> = HashMap::new();\n    for item in &parsed.items {\n        let Some(symbol) = item_name(item) else {\n            continue;\n        };\n        let markers = extract_doc_markers(item_attrs(item));\n        if markers.is_empty() {\n            continue;\n        }\n        map.entry(symbol).or_default().extend(markers);\n    }\n    map\n}\n\npub fn detect_intent_signals(file: &Path, policy: Option<&DeadCodePolicy>) -> IntentMap {\n    let attrs = parse_mmsb_latent_attr(file);\n    let doc_map = scan_doc_comments(file);\n    let docs = merge_doc_intent(doc_map);\n    let dir_map = planned_directory_intent(file, policy);\n    merge_intent_sources(attrs, docs, dir_map)\n}\n\npub fn scan_intent_tags(file: &Path, policy: Option<&DeadCodePolicy>) -> Vec<IntentTag> {\n    let mut tags = Vec::new();\n    let attrs = parse_mmsb_latent_attr(file);\n    for (symbol, items) in attrs {\n        for meta in items {\n            tags.push(IntentTag {\n                symbol: symbol.clone(),\n                file: file.to_path_buf(),\n                line: None,\n                marker: meta.marker,\n                source: meta.source,\n                value: meta.value.clone(),\n            });\n        }\n    }\n\n    let doc_map = scan_doc_comments(file);\n    for (symbol, markers) in doc_map {\n        for marker in markers {\n            tags.push(IntentTag {\n                symbol: symbol.clone(),\n                file: file.to_path_buf(),\n                line: None,\n                marker,\n                source: IntentSource::DocComment,\n                value: None,\n            });\n        }\n    }\n\n    if check_planned_directory(file, policy) {\n        for symbol in collect_symbols(file) {\n            tags.push(IntentTag {\n                symbol,\n                file: file.to_path_buf(),\n                line: None,\n                marker: IntentMarker::Planned,\n                source: IntentSource::Directory,\n                value: None,\n            });\n        }\n    }\n\n    tags\n}\n\npub fn is_cfg_test_item(item: &Item) -> bool {\n    item_attrs(item).iter().any(|attr| {\n        if !attr.path().is_ident(\"cfg\") {\n            return false;\n        }\n        let mut found = false;\n        let _ = attr.parse_nested_meta(|meta| {\n            if meta.path.is_ident(\"test\") {\n                found = true;\n                return Ok(());\n            }\n            if meta.path.is_ident(\"any\") {\n                meta.parse_nested_meta(|nested| {\n                    if nested.path.is_ident(\"test\") {\n                        found = true;\n                    }\n                    Ok(())\n                })?;\n            }\n            Ok(())\n        });\n        found\n    })\n}\n\npub fn detect_test_modules(file: &Path) -> HashSet<String> {\n    let contents = std::fs::read_to_string(file).unwrap_or_default();\n    let parsed = match syn::parse_file(&contents) {\n        Ok(file) => file,\n        Err(_) => return HashSet::new(),\n    };\n    let mut modules = HashSet::new();\n    for item in &parsed.items {\n        if let Item::Mod(item_mod) = item {\n            if is_cfg_test_item(item) {\n                modules.insert(item_mod.ident.to_string());\n            }\n        }\n    }\n    modules\n}\n",
          "updated_content": null
        }
      ],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_write_intelligence_outputs_at_to_src/231_correction_plan_serializer.rs",
      "mutations": [
        {
          "type": "FileEdit",
          "path": "/home/cicero-arch-omen/ai_sandbox/codex-agent/codex_sse/server-tools/MMSB/tools/mmsb-analyzer/src/232_verification_policy_emitter.rs",
          "original_content": "#![allow(dead_code)]\n//! Emit verification policies to JSON.\n\nuse crate::correction_intelligence_report::CorrectionIntelligenceReport;\nuse crate::correction_plan_serializer::serialize_correction_plans;\nuse crate::verification_policy_types::{\n    QualityThresholds, VerificationCheck, VerificationPolicy, VerificationScope,\n};\nuse serde_json::json;\nuse std::path::Path;\n\npub fn emit_verification_policy(\n    policies: &[VerificationPolicy],\n    output_path: &Path,\n) -> std::io::Result<()> {\n    let policy_file = json!({\n        \"version\": \"1.0\",\n        \"policies\": policies.iter().map(|p| json!({\n            \"action_id\": p.action_id,\n            \"scope\": serialize_scope(&p.scope),\n            \"checks\": p.required_checks.iter()\n                .map(serialize_check)\n                .collect::<Vec<_>>(),\n            \"incremental\": p.incremental_eligible,\n            \"estimated_time_seconds\": p.estimated_time_seconds,\n        })).collect::<Vec<_>>()\n    });\n    std::fs::write(output_path, serde_json::to_string_pretty(&policy_file)?)?;\n    Ok(())\n}\n\nfn serialize_scope(scope: &VerificationScope) -> serde_json::Value {\n    match scope {\n        VerificationScope::SyntaxOnly { files } => json!({\n            \"type\": \"SyntaxOnly\",\n            \"files\": files,\n        }),\n        VerificationScope::ModuleLocal { module, transitive_depth } => json!({\n            \"type\": \"ModuleLocal\",\n            \"module\": module,\n            \"transitive_depth\": transitive_depth,\n        }),\n        VerificationScope::CallerChain { root_function } => json!({\n            \"type\": \"CallerChain\",\n            \"root_function\": root_function,\n        }),\n        VerificationScope::FullWorkspace => json!({\n            \"type\": \"FullWorkspace\",\n        }),\n    }\n}\n\nfn serialize_check(check: &VerificationCheck) -> serde_json::Value {\n    match check {\n        VerificationCheck::CargoCheck => json!({ \"type\": \"CargoCheck\" }),\n        VerificationCheck::CargoTest { filter } => json!({\n            \"type\": \"CargoTest\",\n            \"filter\": filter,\n        }),\n        VerificationCheck::InvariantValidation { invariant_ids } => json!({\n            \"type\": \"InvariantValidation\",\n            \"invariant_ids\": invariant_ids,\n        }),\n        VerificationCheck::QualityMetrics { thresholds } => json!({\n            \"type\": \"QualityMetrics\",\n            \"thresholds\": serialize_thresholds(thresholds),\n        }),\n        VerificationCheck::ManualInspection { reason } => json!({\n            \"type\": \"ManualInspection\",\n            \"reason\": reason,\n        }),\n    }\n}\n\nfn serialize_thresholds(thresholds: &QualityThresholds) -> serde_json::Value {\n    json!({\n        \"min_cohesion_delta\": thresholds.min_cohesion_delta,\n        \"max_violation_delta\": thresholds.max_violation_delta,\n        \"max_complexity_delta\": thresholds.max_complexity_delta,\n    })\n}\n\npub fn write_intelligence_outputs_at(\n    report: &CorrectionIntelligenceReport,\n    output_dir: &Path,\n    correction_json: Option<&Path>,\n    verification_policy_json: Option<&Path>,\n) -> std::io::Result<()> {\n    std::fs::create_dir_all(output_dir)?;\n    let json_path = correction_json\n        .map(|p| p.to_path_buf())\n        .unwrap_or_else(|| output_dir.join(\"correction_intelligence.json\"));\n    if let Some(parent) = json_path.parent() {\n        std::fs::create_dir_all(parent)?;\n    }\n    let contract = serialize_correction_plans(report);\n    std::fs::write(&json_path, serde_json::to_string_pretty(&contract)?)?;\n\n    let policy_path = verification_policy_json\n        .map(|p| p.to_path_buf())\n        .unwrap_or_else(|| output_dir.join(\"verification_policy.json\"));\n    if let Some(parent) = policy_path.parent() {\n        std::fs::create_dir_all(parent)?;\n    }\n    emit_verification_policy(&report.verification_policies, &policy_path)?;\n    Ok(())\n}\n",
          "updated_content": null
        },
        {
          "type": "FileEdit",
          "path": "/home/cicero-arch-omen/ai_sandbox/codex-agent/codex_sse/server-tools/MMSB/tools/mmsb-analyzer/src/231_correction_plan_serializer.rs",
          "original_content": "#![allow(dead_code)]\n//! Serialize correction plans to JSON values.\n\nuse crate::correction_intelligence_report::CorrectionIntelligenceReport;\nuse crate::correction_plan_types::{CorrectionPlan, CorrectionStrategy};\nuse crate::quality_delta_types::RollbackCriteria;\nuse crate::verification_policy_types::{QualityThresholds, VerificationCheck, VerificationPolicy, VerificationScope};\nuse serde_json::{json, Value};\n\npub fn serialize_correction_plan(\n    plan: &CorrectionPlan,\n    verification: &VerificationPolicy,\n    rollback: &RollbackCriteria,\n) -> Value {\n    json!({\n        \"action_id\": plan.action_id,\n        \"tier\": format!(\"{:?}\", plan.tier),\n        \"confidence\": plan.confidence,\n        \"estimated_fix_time_seconds\": plan.estimated_fix_time_seconds,\n        \"predicted_violations\": plan.predicted_violations.iter().map(|v| json!({\n            \"type\": format!(\"{:?}\", v.violation_type),\n            \"severity\": format!(\"{:?}\", v.severity),\n            \"affected_files\": v.affected_files,\n            \"confidence\": v.confidence,\n        })).collect::<Vec<_>>(),\n        \"correction_strategies\": plan.strategies.iter().map(serialize_strategy).collect::<Vec<_>>(),\n        \"verification_policy\": {\n            \"scope\": serialize_scope(&verification.scope),\n            \"required_checks\": verification.required_checks.iter()\n                .map(serialize_check)\n                .collect::<Vec<_>>(),\n            \"incremental_eligible\": verification.incremental_eligible,\n            \"estimated_time_seconds\": verification.estimated_time_seconds,\n        },\n        \"rollback_criteria\": {\n            \"mandatory\": rollback.mandatory_rollback_if.iter()\n                .map(|c| format!(\"{:?}\", c))\n                .collect::<Vec<_>>(),\n            \"suggested\": rollback.suggested_rollback_if.iter()\n                .map(|c| format!(\"{:?}\", c))\n                .collect::<Vec<_>>(),\n        }\n    })\n}\n\nfn serialize_scope(scope: &VerificationScope) -> Value {\n    match scope {\n        VerificationScope::SyntaxOnly { files } => json!({\n            \"type\": \"SyntaxOnly\",\n            \"files\": files,\n        }),\n        VerificationScope::ModuleLocal { module, transitive_depth } => json!({\n            \"type\": \"ModuleLocal\",\n            \"module\": module,\n            \"transitive_depth\": transitive_depth,\n        }),\n        VerificationScope::CallerChain { root_function } => json!({\n            \"type\": \"CallerChain\",\n            \"root_function\": root_function,\n        }),\n        VerificationScope::FullWorkspace => json!({\n            \"type\": \"FullWorkspace\",\n        }),\n    }\n}\n\nfn serialize_check(check: &VerificationCheck) -> Value {\n    match check {\n        VerificationCheck::CargoCheck => json!({ \"type\": \"CargoCheck\" }),\n        VerificationCheck::CargoTest { filter } => json!({\n            \"type\": \"CargoTest\",\n            \"filter\": filter,\n        }),\n        VerificationCheck::InvariantValidation { invariant_ids } => json!({\n            \"type\": \"InvariantValidation\",\n            \"invariant_ids\": invariant_ids,\n        }),\n        VerificationCheck::QualityMetrics { thresholds } => json!({\n            \"type\": \"QualityMetrics\",\n            \"thresholds\": serialize_thresholds(thresholds),\n        }),\n        VerificationCheck::ManualInspection { reason } => json!({\n            \"type\": \"ManualInspection\",\n            \"reason\": reason,\n        }),\n    }\n}\n\nfn serialize_thresholds(thresholds: &QualityThresholds) -> Value {\n    json!({\n        \"min_cohesion_delta\": thresholds.min_cohesion_delta,\n        \"max_violation_delta\": thresholds.max_violation_delta,\n        \"max_complexity_delta\": thresholds.max_complexity_delta,\n    })\n}\n\nfn serialize_strategy(strategy: &CorrectionStrategy) -> Value {\n    match strategy {\n        CorrectionStrategy::AddImport { module_path, symbol } => json!({\n            \"type\": \"AddImport\",\n            \"module_path\": module_path,\n            \"symbol\": symbol,\n        }),\n        CorrectionStrategy::UpdatePath { old_path, new_path } => json!({\n            \"type\": \"UpdatePath\",\n            \"old_path\": old_path,\n            \"new_path\": new_path,\n        }),\n        CorrectionStrategy::ReExport { from_module, symbol } => json!({\n            \"type\": \"ReExport\",\n            \"from_module\": from_module,\n            \"symbol\": symbol,\n        }),\n        CorrectionStrategy::RenameWithSuffix { original, suffix } => json!({\n            \"type\": \"RenameWithSuffix\",\n            \"original\": original,\n            \"suffix\": suffix,\n        }),\n        CorrectionStrategy::MoveToLayer { function, target_layer } => json!({\n            \"type\": \"MoveToLayer\",\n            \"function\": function,\n            \"target_layer\": target_layer,\n        }),\n        CorrectionStrategy::EnsureImports { function, target_layer } => json!({\n            \"type\": \"EnsureImports\",\n            \"function\": function,\n            \"target_layer\": target_layer,\n        }),\n        CorrectionStrategy::UpdateCaller { caller_file, old_ref, new_ref } => json!({\n            \"type\": \"UpdateCaller\",\n            \"caller_file\": caller_file,\n            \"old_ref\": old_ref,\n            \"new_ref\": new_ref,\n        }),\n        CorrectionStrategy::ManualReview { reason, context } => json!({\n            \"type\": \"ManualReview\",\n            \"reason\": reason,\n            \"context\": context,\n        }),\n    }\n}\n\npub fn serialize_correction_plans(\n    report: &CorrectionIntelligenceReport,\n) -> serde_json::Value {\n    let items = report\n        .correction_plans\n        .iter()\n        .zip(report.verification_policies.iter())\n        .zip(report.rollback_criteria.iter())\n        .map(|((plan, policy), rollback)| serialize_correction_plan(plan, policy, rollback))\n        .collect::<Vec<_>>();\n    json!({\n        \"version\": report.version,\n        \"timestamp\": report.timestamp,\n        \"project_root\": report.project_root,\n        \"actions_analyzed\": report.actions_analyzed,\n        \"correction_plans\": items,\n        \"quality_deltas\": report.quality_deltas,\n        \"summary\": report.summary,\n    })\n}\n",
          "updated_content": "#![allow(dead_code)]\nuse crate::correction_plan_serializer::serialize_correction_plans;\nuse std::path::Path;\n//! Serialize correction plans to JSON values.\n\nuse crate::correction_intelligence_report::CorrectionIntelligenceReport;\nuse crate::correction_plan_types::{CorrectionPlan, CorrectionStrategy};\nuse crate::quality_delta_types::RollbackCriteria;\nuse crate::verification_policy_types::{QualityThresholds, VerificationCheck, VerificationPolicy, VerificationScope};\nuse serde_json::{json, Value};\n\npub fn serialize_correction_plan(\n    plan: &CorrectionPlan,\n    verification: &VerificationPolicy,\n    rollback: &RollbackCriteria,\n) -> Value {\n    json!({\n        \"action_id\": plan.action_id,\n        \"tier\": format!(\"{:?}\", plan.tier),\n        \"confidence\": plan.confidence,\n        \"estimated_fix_time_seconds\": plan.estimated_fix_time_seconds,\n        \"predicted_violations\": plan.predicted_violations.iter().map(|v| json!({\n            \"type\": format!(\"{:?}\", v.violation_type),\n            \"severity\": format!(\"{:?}\", v.severity),\n            \"affected_files\": v.affected_files,\n            \"confidence\": v.confidence,\n        })).collect::<Vec<_>>(),\n        \"correction_strategies\": plan.strategies.iter().map(serialize_strategy).collect::<Vec<_>>(),\n        \"verification_policy\": {\n            \"scope\": serialize_scope(&verification.scope),\n            \"required_checks\": verification.required_checks.iter()\n                .map(serialize_check)\n                .collect::<Vec<_>>(),\n            \"incremental_eligible\": verification.incremental_eligible,\n            \"estimated_time_seconds\": verification.estimated_time_seconds,\n        },\n        \"rollback_criteria\": {\n            \"mandatory\": rollback.mandatory_rollback_if.iter()\n                .map(|c| format!(\"{:?}\", c))\n                .collect::<Vec<_>>(),\n            \"suggested\": rollback.suggested_rollback_if.iter()\n                .map(|c| format!(\"{:?}\", c))\n                .collect::<Vec<_>>(),\n        }\n    })\n}\n\nfn serialize_scope(scope: &VerificationScope) -> Value {\n    match scope {\n        VerificationScope::SyntaxOnly { files } => json!({\n            \"type\": \"SyntaxOnly\",\n            \"files\": files,\n        }),\n        VerificationScope::ModuleLocal { module, transitive_depth } => json!({\n            \"type\": \"ModuleLocal\",\n            \"module\": module,\n            \"transitive_depth\": transitive_depth,\n        }),\n        VerificationScope::CallerChain { root_function } => json!({\n            \"type\": \"CallerChain\",\n            \"root_function\": root_function,\n        }),\n        VerificationScope::FullWorkspace => json!({\n            \"type\": \"FullWorkspace\",\n        }),\n    }\n}\n\nfn serialize_check(check: &VerificationCheck) -> Value {\n    match check {\n        VerificationCheck::CargoCheck => json!({ \"type\": \"CargoCheck\" }),\n        VerificationCheck::CargoTest { filter } => json!({\n            \"type\": \"CargoTest\",\n            \"filter\": filter,\n        }),\n        VerificationCheck::InvariantValidation { invariant_ids } => json!({\n            \"type\": \"InvariantValidation\",\n            \"invariant_ids\": invariant_ids,\n        }),\n        VerificationCheck::QualityMetrics { thresholds } => json!({\n            \"type\": \"QualityMetrics\",\n            \"thresholds\": serialize_thresholds(thresholds),\n        }),\n        VerificationCheck::ManualInspection { reason } => json!({\n            \"type\": \"ManualInspection\",\n            \"reason\": reason,\n        }),\n    }\n}\n\nfn serialize_thresholds(thresholds: &QualityThresholds) -> Value {\n    json!({\n        \"min_cohesion_delta\": thresholds.min_cohesion_delta,\n        \"max_violation_delta\": thresholds.max_violation_delta,\n        \"max_complexity_delta\": thresholds.max_complexity_delta,\n    })\n}\n\nfn serialize_strategy(strategy: &CorrectionStrategy) -> Value {\n    match strategy {\n        CorrectionStrategy::AddImport { module_path, symbol } => json!({\n            \"type\": \"AddImport\",\n            \"module_path\": module_path,\n            \"symbol\": symbol,\n        }),\n        CorrectionStrategy::UpdatePath { old_path, new_path } => json!({\n            \"type\": \"UpdatePath\",\n            \"old_path\": old_path,\n            \"new_path\": new_path,\n        }),\n        CorrectionStrategy::ReExport { from_module, symbol } => json!({\n            \"type\": \"ReExport\",\n            \"from_module\": from_module,\n            \"symbol\": symbol,\n        }),\n        CorrectionStrategy::RenameWithSuffix { original, suffix } => json!({\n            \"type\": \"RenameWithSuffix\",\n            \"original\": original,\n            \"suffix\": suffix,\n        }),\n        CorrectionStrategy::MoveToLayer { function, target_layer } => json!({\n            \"type\": \"MoveToLayer\",\n            \"function\": function,\n            \"target_layer\": target_layer,\n        }),\n        CorrectionStrategy::EnsureImports { function, target_layer } => json!({\n            \"type\": \"EnsureImports\",\n            \"function\": function,\n            \"target_layer\": target_layer,\n        }),\n        CorrectionStrategy::UpdateCaller { caller_file, old_ref, new_ref } => json!({\n            \"type\": \"UpdateCaller\",\n            \"caller_file\": caller_file,\n            \"old_ref\": old_ref,\n            \"new_ref\": new_ref,\n        }),\n        CorrectionStrategy::ManualReview { reason, context } => json!({\n            \"type\": \"ManualReview\",\n            \"reason\": reason,\n            \"context\": context,\n        }),\n    }\n}\n\npub fn serialize_correction_plans(\n    report: &CorrectionIntelligenceReport,\n) -> serde_json::Value {\n    let items = report\n        .correction_plans\n        .iter()\n        .zip(report.verification_policies.iter())\n        .zip(report.rollback_criteria.iter())\n        .map(|((plan, policy), rollback)| serialize_correction_plan(plan, policy, rollback))\n        .collect::<Vec<_>>();\n    json!({\n        \"version\": report.version,\n        \"timestamp\": report.timestamp,\n        \"project_root\": report.project_root,\n        \"actions_analyzed\": report.actions_analyzed,\n        \"correction_plans\": items,\n        \"quality_deltas\": report.quality_deltas,\n        \"summary\": report.summary,\n    })\n}\n\npub fn write_intelligence_outputs_at(\n    report: &CorrectionIntelligenceReport,\n    output_dir: &Path,\n    correction_json: Option<&Path>,\n    verification_policy_json: Option<&Path>,\n) -> std::io::Result<()> {\n    std::fs::create_dir_all(output_dir)?;\n    let json_path = correction_json\n        .map(|p| p.to_path_buf())\n        .unwrap_or_else(|| output_dir.join(\"correction_intelligence.json\"));\n    if let Some(parent) = json_path.parent() {\n        std::fs::create_dir_all(parent)?;\n    }\n    let contract = serialize_correction_plans(report);\n    std::fs::write(&json_path, serde_json::to_string_pretty(&contract)?)?;\n\n    let policy_path = verification_policy_json\n        .map(|p| p.to_path_buf())\n        .unwrap_or_else(|| output_dir.join(\"verification_policy.json\"));\n    if let Some(parent) = policy_path.parent() {\n        std::fs::create_dir_all(parent)?;\n    }\n    emit_verification_policy(&report.verification_policies, &policy_path)?;\n    Ok(())\n}\n"
        }
      ],
      "applied": false,
      "errors": []
    }
  ]
}