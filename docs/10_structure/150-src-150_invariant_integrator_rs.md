# Structure Group: src/150_invariant_integrator.rs

## File: src/150_invariant_integrator.rs

- Layer(s): 150_invariant_integrator.rs
- Language coverage: Rust (3)
- Element types: Impl (1), Module (1), Struct (1)
- Total elements: 3

### Elements

- [Rust | Struct] `InvariantDetector` (line 0, pub)
  - Signature: `# [doc = " Main invariant detector that orchestrates all detection strategies"] pub struct InvariantDetector < 'a > {...`
  - Generics: 'a
- [Rust | Impl] `impl < 'a > InvariantDetector < 'a > { # [doc = " Create a new invariant detector"] pub fn new (analysis_result : & 'a AnalysisResult , call_graph_nodes : & HashMap < String , CallGraphNode > ,) -> Self { let mut graph = DiGraph :: new () ; let mut node_indices = HashMap :: new () ; for (name , _) in call_graph_nodes { let idx = graph . add_node (name . clone ()) ; node_indices . insert (name . clone () , idx) ; } for (caller , node) in call_graph_nodes { if let Some (& caller_idx) = node_indices . get (caller) { for callee in & node . calls { if let Some (& callee_idx) = node_indices . get (callee) { graph . add_edge (caller_idx , callee_idx , ()) ; } } } } Self { analysis_result , call_graph : graph , } } # [doc = " Detect all invariants across all detection strategies"] pub fn detect_all (& self) -> InvariantAnalysisResult { let mut result = InvariantAnalysisResult :: new () ; println ! ("ðŸ” Detecting invariants...") ; println ! ("  â”œâ”€ Detecting structural invariants (graph-based)...") ; let structural_detector = StructuralDetector :: new (self . call_graph . clone ()) ; let structural_invs = structural_detector . detect_all () ; println ! ("     Found {} structural invariants (from call graph)" , structural_invs . len ()) ; for inv in structural_invs { result . add_invariant (inv) ; } println ! ("  â”œâ”€ Enhanced structural detection (call graph from analysis)...") ; let enhanced_structural_invs = StructuralDetector :: detect_from_analysis (self . analysis_result) ; println ! ("     Found {} enhanced structural invariants" , enhanced_structural_invs . len ()) ; for inv in enhanced_structural_invs { result . add_invariant (inv) ; } println ! ("  â”œâ”€ Detecting semantic invariants...") ; let semantic_detector = SemanticDetector :: new (& self . analysis_result . elements) ; let semantic_invs = semantic_detector . detect_all () ; println ! ("     Found {} semantic invariants" , semantic_invs . len ()) ; for inv in semantic_invs { result . add_invariant (inv) ; } println ! ("  â”œâ”€ Detecting path-intersection invariants...") ; let path_detector = PathDetector :: new (self . call_graph . clone ()) ; let path_invs = path_detector . detect_all (10 , 100) ; println ! ("     Found {} path-intersection invariants" , path_invs . len ()) ; for inv in path_invs { result . add_invariant (inv) ; } println ! ("  â”œâ”€ Inferring layers from call graph...") ; let layers = infer_layers (& self . call_graph , 100) ; result . layer_assignments = layers . clone () ; println ! ("     Inferred {} layer assignments" , layers . len ()) ; println ! ("  â””â”€ Checking for violations...") ; let violations = detect_layer_violations (& layers , & self . call_graph) ; for (caller , callee , caller_layer , callee_layer) in violations { let violation = InvariantViolation { invariant : Invariant :: new (caller . clone () , "" . to_string () , InvariantKind :: Structural (StructuralInvariant :: LayerFixed { layer : caller_layer , }) , InvariantStrength :: Proven , "Layer violation detected" . to_string () ,) , violation_description : format ! ("{} (layer {}) calls {} (layer {}) - violation!" , caller , caller_layer , callee , callee_layer) , severity : ViolationSeverity :: Critical , suggested_fix : Some (format ! ("Move {} to layer > {} or refactor call" , caller , callee_layer)) , } ; result . add_violation (violation) ; } result . stats . update_totals () ; println ! () ; println ! ("âœ… Invariants: {} (proven: {}, empirical: {}, heuristic: {})" , result . stats . total_count , result . stats . proven_count , result . stats . empirical_count , result . stats . heuristic_count) ; println ! ("âœ… Violations: {}" , result . stats . violation_count) ; result } # [doc = " Check for violations of existing invariants"] # [allow (dead_code)] pub fn check_violations (& self , invariants : & [Invariant]) -> Vec < InvariantViolation > { let mut violations = Vec :: new () ; let layers = infer_layers (& self . call_graph , 100) ; let layer_violations = detect_layer_violations (& layers , & self . call_graph) ; for (caller , callee , caller_layer , callee_layer) in layer_violations { if let Some (inv) = invariants . iter () . find (| i | i . target == caller) { let violation = InvariantViolation { invariant : inv . clone () , violation_description : format ! ("{} (layer {}) calls {} (layer {})" , caller , caller_layer , callee , callee_layer) , severity : ViolationSeverity :: Critical , suggested_fix : Some (format ! ("Refactor {} to respect layer constraints" , caller)) , } ; violations . push (violation) ; } } violations } # [doc = " Generate refactoring constraints from detected invariants"] pub fn generate_constraints (& self , result : & InvariantAnalysisResult) -> Vec < crate :: refactor_constraints :: RefactorConstraint > { generate_constraints (result) } } . self_ty` (line 0, priv)
- [Rust | Module] `tests` (line 0, priv)

