# Structure Group: src/140_path_detector.rs

## File: src/140_path_detector.rs

- Layer(s): 140_path_detector.rs
- Language coverage: Rust (4)
- Element types: Impl (1), Module (1), Struct (2)
- Total elements: 4

### Elements

- [Rust | Struct] `PathDetector` (line 0, pub)
  - Signature: `# [doc = " Path invariant detector"] pub struct PathDetector { graph : DiGraph < String , () > , compression : SccCom...`
- [Rust | Struct] `PathStats` (line 0, pub)
  - Signature: `# [derive (Debug , Clone)] # [allow (dead_code)] pub struct PathStats { pub original_nodes : usize , pub compressed_n...`
- [Rust | Impl] `impl PathDetector { pub fn new (graph : DiGraph < String , () >) -> Self { let compression = SccCompression :: new (graph . clone ()) ; Self { graph , compression } } # [doc = " Detect all path-intersection invariants"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `max_depth` - Maximum path depth to explore"] # [doc = " * `max_paths_per_node` - Maximum paths to check per node"] pub fn detect_all (& self , max_depth : usize , max_paths_per_node : usize) -> Vec < Invariant > { let mut invariants = Vec :: new () ; for node_idx in self . compression . compressed_graph . node_indices () { let members = & self . compression . compressed_graph [node_idx] ; for member in members { if let Some (inv) = self . compute_path_intersection (member , max_depth , max_paths_per_node) { invariants . push (inv) ; } } } invariants } # [doc = " Compute path-intersection invariant for a specific node"] fn compute_path_intersection (& self , target : & str , max_depth : usize , max_paths : usize ,) -> Option < Invariant > { let target_idx = self . graph . node_indices () . find (| & idx | self . graph [idx] == target) ? ; let leaf_nodes : Vec < NodeIndex > = self . graph . node_indices () . filter (| & idx | { self . graph . neighbors_directed (idx , Direction :: Outgoing) . count () == 0 }) . collect () ; let mut all_paths = Vec :: new () ; let mut paths_found = 0 ; for leaf_idx in leaf_nodes { let paths : Vec < Vec < NodeIndex > > = all_simple_paths (& self . graph , target_idx , leaf_idx , 0 , Some (max_depth) ,) . take (max_paths - paths_found) . collect () ; paths_found += paths . len () ; all_paths . extend (paths) ; if paths_found >= max_paths { break ; } } if all_paths . len () < 2 { return None ; } let path_facts : Vec < HashSet < String > > = all_paths . iter () . map (| path | self . extract_facts_from_path (path)) . collect () ; let mut intersection = path_facts [0] . clone () ; for facts in & path_facts [1 ..] { intersection = intersection . intersection (facts) . cloned () . collect () ; } if intersection . is_empty () { return None ; } Some (Invariant :: new (target . to_string () , "" . to_string () , InvariantKind :: PathIntersection (PathIntersectionInvariant { facts : intersection , paths_analyzed : all_paths . len () , max_depth , }) , InvariantStrength :: Empirical { paths_checked : all_paths . len () , } , format ! ("Facts hold on all {} paths (max depth: {})" , all_paths . len () , max_depth) ,)) } # [doc = " Extract symbolic facts from a path"] # [doc = ""] # [doc = " This is a simplified version - a full implementation would use"] # [doc = " abstract interpretation or symbolic execution"] fn extract_facts_from_path (& self , path : & [NodeIndex]) -> HashSet < String > { let mut facts = HashSet :: new () ; facts . insert (format ! ("path_length_{}" , path . len ())) ; for & node_idx in path { let name = & self . graph [node_idx] ; facts . insert (format ! ("visits_{}" , name)) ; } for window in path . windows (2) { let from = & self . graph [window [0]] ; let to = & self . graph [window [1]] ; facts . insert (format ! ("edge_{}_to_{}" , from , to)) ; } if let Some (& last) = path . last () { let out_degree = self . graph . neighbors_directed (last , Direction :: Outgoing) . count () ; if out_degree == 0 { facts . insert ("reaches_leaf" . to_string ()) ; } } facts } # [doc = " Get statistics about path enumeration"] # [allow (dead_code)] pub fn get_stats (& self) -> PathStats { let total_nodes = self . graph . node_count () ; let compressed_nodes = self . compression . compressed_graph . node_count () ; PathStats { original_nodes : total_nodes , compressed_nodes , is_dag : self . compression . is_dag () , } } } . self_ty` (line 0, priv)
- [Rust | Module] `tests` (line 0, priv)

