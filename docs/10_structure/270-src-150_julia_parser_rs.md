# Structure Group: src/150_julia_parser.rs

## File: src/150_julia_parser.rs

- Layer(s): 150_julia_parser.rs
- Language coverage: Rust (12)
- Element types: Function (10), Impl (1), Struct (1)
- Total elements: 12

### Elements

- [Rust | Struct] `JuliaAnalyzer` (line 0, pub)
  - Signature: `pub struct JuliaAnalyzer { script_path : PathBuf , root_path : PathBuf , project_dir : PathBuf , dot_root : PathBuf ,...`
- [Rust | Function] `extract_calls_from_lines` (line 0, priv)
  - Signature: `fn extract_calls_from_lines (lines : & [String]) -> Vec < String > { let joined = lines . join ("\n") ; extract_calls...`
  - Calls: join, extract_calls_from_text
- [Rust | Function] `extract_calls_from_text` (line 0, priv)
  - Signature: `fn extract_calls_from_text (text : & str) -> Vec < String > { let mut calls = Vec :: new () ; for capture in CALL_RE ...`
  - Calls: Vec::new, captures_iter, get, as_str, is_reserved, push, to_string, sort, dedup
- [Rust | Function] `find_julia_project_dir` (line 0, priv)
  - Signature: `fn find_julia_project_dir (script_path : & Path) -> PathBuf { let mut current = script_path . parent () ; while let S...`
  - Calls: parent, exists, join, to_path_buf, parent, to_path_buf, unwrap_or_else, parent, Path::new
- [Rust | Impl] `impl JuliaAnalyzer { pub fn new (root_path : PathBuf , script_path : PathBuf , dot_root : PathBuf) -> Self { let _base_dir = script_path . parent () . map (Path :: to_path_buf) . unwrap_or_else (| | PathBuf :: from (".")) ; let julia_bin = resolve_julia_binary () ; let project_dir = find_julia_project_dir (& script_path) ; Self { root_path , script_path , project_dir , dot_root , julia_bin , script_disabled : AtomicBool :: new (false) , global_cfg_generated : AtomicBool :: new (false) , } } # [allow (dead_code)] pub fn generate_global_cfgs (& self) -> Result < () > { self . ensure_global_cfgs () } pub fn analyze_file (& self , file_path : & Path) -> Result < AnalysisResult > { println ! ("    [Julia] Analyzing {:?}" , file_path) ; if ! self . script_disabled . load (Ordering :: Relaxed) { self . ensure_global_cfgs () ? ; match self . run_script (file_path) { Ok (result) => return Ok (result) , Err (err) => { eprintln ! ("Warning: Julia script execution failed ({err}). Falling back to internal parser for the remaining files.") ; self . script_disabled . store (true , Ordering :: Relaxed) ; } } } self . fallback_parse (file_path) } fn ensure_global_cfgs (& self) -> Result < () > { if self . global_cfg_generated . load (Ordering :: Relaxed) { return Ok (()) ; } let status = Command :: new (& self . julia_bin) . arg ("--startup-file=no") . arg (& self . script_path) . arg ("--global-cfgs") . arg (& self . root_path) . arg (& self . dot_root) . env ("JULIA_PROJECT" , & self . project_dir) . stderr (Stdio :: inherit ()) . stdout (Stdio :: inherit ()) . status () . context ("Failed to execute Julia analyzer for global CFG generation") ? ; if ! status . success () { return Err (anyhow ! ("Julia analyzer exited with {} while generating global CFGs" , status)) ; } self . global_cfg_generated . store (true , Ordering :: Relaxed) ; Ok (()) } fn run_script (& self , file_path : & Path) -> Result < AnalysisResult > { let dot_dir = self . compute_dot_dir (file_path) ; fs :: create_dir_all (& dot_dir) ? ; let output = Command :: new (& self . julia_bin) . arg ("--startup-file=no") . arg (& self . script_path) . arg (file_path) . arg (& dot_dir) . arg (& self . root_path) . env ("JULIA_PROJECT" , & self . project_dir) . stderr (Stdio :: inherit ()) . output () . with_context (| | format ! ("Failed to execute Julia analyzer on {:?}" , file_path)) ? ; if ! output . status . success () { return Err (anyhow ! ("Julia analyzer exited with {}: {}" , output . status , "check stderr output above")) ; } let stdout = String :: from_utf8_lossy (& output . stdout) ; let json_line = stdout . lines () . find (| line | line . trim_start () . starts_with ('[') || line . trim_start () . starts_with ('{')) . unwrap_or ("") ; let julia_elements : Vec < JuliaElement > = serde_json :: from_str (& stdout) . or_else (| _ | serde_json :: from_str (json_line)) . with_context (| | { format ! ("Failed to parse Julia analyzer output. Raw output: {}" , stdout) }) ? ; let mut result = AnalysisResult :: new () ; let layer = self . extract_layer (file_path) ; for elem in julia_elements { let element_type = match elem . element_type . as_str () { "struct" => ElementType :: Struct , "function" => ElementType :: Function , "module" => ElementType :: Module , _ => continue , } ; let file_path = relativize_path (Path :: new (& elem . file_path) , & self . root_path) ; result . add_element (CodeElement { element_type , name : elem . name , file_path , line_number : elem . line_number , language : Language :: Julia , layer : layer . clone () , signature : elem . signature , calls : elem . calls , visibility : Visibility :: Public , generic_params : Vec :: new () , }) ; } Ok (result) } fn fallback_parse (& self , file_path : & Path) -> Result < AnalysisResult > { let content = fs :: read_to_string (file_path) . with_context (| | format ! ("Failed to read Julia file {:?}" , file_path)) ? ; let mut result = AnalysisResult :: new () ; let layer = self . extract_layer (file_path) ; let file_path_str = relativize_path (file_path , & self . root_path) ; let lines : Vec < & str > = content . lines () . collect () ; let mut idx = 0 ; while idx < lines . len () { let line = lines [idx] ; let trimmed = line . trim () ; if trimmed . is_empty () || trimmed . starts_with ('#') { idx += 1 ; continue ; } if let Some (module_name) = parse_module_name (trimmed) { result . add_element (CodeElement { element_type : ElementType :: Module , name : module_name , file_path : file_path_str . clone () , line_number : idx + 1 , language : Language :: Julia , layer : layer . clone () , signature : trimmed . to_string () , calls : Vec :: new () , visibility : Visibility :: Public , generic_params : Vec :: new () , }) ; idx += 1 ; continue ; } if let Some (struct_name) = parse_struct_name (trimmed) { result . add_element (CodeElement { element_type : ElementType :: Struct , name : struct_name , file_path : file_path_str . clone () , line_number : idx + 1 , language : Language :: Julia , layer : layer . clone () , signature : trimmed . to_string () , calls : Vec :: new () , visibility : Visibility :: Public , generic_params : Vec :: new () , }) ; idx += 1 ; continue ; } if trimmed . starts_with ("function ") { let (consumed , maybe_element) = self . parse_function_block (& file_path_str , & layer , & lines , idx) ; if let Some (element) = maybe_element { result . add_element (element) ; } idx += consumed . max (1) ; continue ; } if let Some (element) = self . parse_inline_function (& file_path_str , & layer , lines [idx] , idx + 1) { result . add_element (element) ; } idx += 1 ; } Ok (result) } fn parse_function_block (& self , file_path : & str , layer : & str , lines : & [& str] , start_idx : usize ,) -> (usize , Option < CodeElement >) { let mut header = lines [start_idx] . trim () . to_string () ; let mut consumed = 1usize ; while paren_balance (& header) > 0 && start_idx + consumed < lines . len () { header . push (' ') ; header . push_str (lines [start_idx + consumed] . trim ()) ; consumed += 1 ; } let mut inline_body = None ; if let Some (eq_idx) = header . find ('=') { inline_body = Some (header [eq_idx + 1 ..] . trim () . to_string ()) ; header = header [.. eq_idx] . trim () . to_string () ; } let mut body_lines = Vec :: new () ; let mut total_consumed = consumed ; if inline_body . is_none () { let mut depth = 1i32 ; let mut idx = start_idx + consumed ; while idx < lines . len () { let current = lines [idx] ; let trimmed = current . trim () ; if trimmed . starts_with ("function ") || trimmed . starts_with ("let") || trimmed . starts_with ("if ") || trimmed == "if" || trimmed . starts_with ("for ") || trimmed . starts_with ("while ") || trimmed . starts_with ("begin") || trimmed . starts_with ("try") || trimmed . starts_with ("module ") || trimmed . starts_with ("baremodule ") || trimmed . starts_with ("struct ") || trimmed . starts_with ("mutable struct ") || trimmed . starts_with ("quote") { depth += 1 ; } if trimmed == "end" || trimmed . starts_with ("end ") { depth -= 1 ; idx += 1 ; if depth == 0 { break ; } else { continue ; } } body_lines . push (current . to_string ()) ; idx += 1 ; } total_consumed = idx - start_idx ; } let signature = header . trim () . trim_start_matches ("function") . trim () . to_string () ; if signature . is_empty () { return (total_consumed , None) ; } let func_name = signature . split (| c : char | c == '(' || c . is_whitespace ()) . next () . unwrap_or ("anonymous") . to_string () ; let calls = if let Some (inline) = inline_body { extract_calls_from_text (& inline) } else { extract_calls_from_lines (& body_lines) } ; let element = CodeElement { element_type : ElementType :: Function , name : func_name , file_path : file_path . to_string () , line_number : start_idx + 1 , language : Language :: Julia , layer : layer . to_string () , signature , calls , visibility : Visibility :: Public , generic_params : Vec :: new () , } ; (total_consumed , Some (element)) } fn parse_inline_function (& self , file_path : & str , layer : & str , line : & str , line_number : usize ,) -> Option < CodeElement > { let trimmed = line . trim () ; if trimmed . starts_with ("function ") || trimmed . starts_with ('#') { return None ; } let captures = INLINE_FN_RE . captures (trimmed) ? ; let func_name = captures . get (1) ? . as_str () . to_string () ; let args = captures . get (2) . map (| m | m . as_str ()) . unwrap_or ("()") ; let body = captures . get (3) . map (| m | m . as_str ()) . unwrap_or ("") . to_string () ; let signature = format ! ("{}{}" , func_name , args) ; let calls = extract_calls_from_text (& body) ; Some (CodeElement { element_type : ElementType :: Function , name : func_name , file_path : file_path . to_string () , line_number , language : Language :: Julia , layer : layer . to_string () , signature , calls , visibility : Visibility :: Public , generic_params : Vec :: new () , }) } fn extract_layer (& self , path : & Path) -> String { for component in path . components () { if let Some (name) = component . as_os_str () . to_str () { if name . chars () . next () . map_or (false , | c | c . is_ascii_digit ()) { if let Some (pos) = name . find ('_') { if name [.. pos] . chars () . all (| c | c . is_ascii_digit ()) { return name . to_string () ; } } } } } "root" . to_string () } fn compute_dot_dir (& self , path : & Path) -> PathBuf { if let Ok (relative) = path . strip_prefix (& self . root_path) { if let Some (parent) = relative . parent () { return self . dot_root . join (parent) ; } return self . dot_root . clone () ; } let slug = slugify_relative (& self . root_path , path) ; self . dot_root . join (slug) } } . self_ty` (line 0, priv)
- [Rust | Function] `is_reserved` (line 0, priv)
  - Signature: `fn is_reserved (name : & str) -> bool { matches ! (name , "if" | "for" | "while" | "begin" | "let" | "struct" | "muta...`
- [Rust | Function] `paren_balance` (line 0, priv)
  - Signature: `fn paren_balance (input : & str) -> i32 { let mut balance = 0i32 ; for ch in input . chars () { if ch == '(' { balanc...`
  - Calls: chars
- [Rust | Function] `parse_module_name` (line 0, priv)
  - Signature: `fn parse_module_name (line : & str) -> Option < String > { if line . starts_with ("module ") { return line . split_wh...`
  - Calls: starts_with, map, nth, split_whitespace, to_string, trim_end_matches, starts_with, map, nth, split_whitespace, to_string, trim_end_matches
- [Rust | Function] `parse_struct_name` (line 0, priv)
  - Signature: `fn parse_struct_name (line : & str) -> Option < String > { if line . starts_with ("mutable struct ") || line . starts...`
  - Calls: starts_with, starts_with, starts_with, collect, split_whitespace, map, get, to_string, trim_end_matches, unwrap_or, next, split
- [Rust | Function] `relativize_path` (line 0, priv)
  - Signature: `fn relativize_path (path : & Path , root : & Path) -> String { if let Ok (stripped) = path . strip_prefix (root) { st...`
  - Calls: strip_prefix, to_string, to_string_lossy, to_string, to_string_lossy
- [Rust | Function] `resolve_julia_binary` (line 0, priv)
  - Signature: `fn resolve_julia_binary () -> PathBuf { if let Ok (custom) = env :: var ("JULIA_BINARY") { let candidate = PathBuf ::...`
  - Calls: env::var, PathBuf::from, exists, env::var, join, Path::new, fs::read_dir, flatten, path, is_dir, and_then, file_name, to_str, starts_with, join, exists, PathBuf::from, exists, PathBuf::from
- [Rust | Function] `slugify_relative` (line 0, priv)
  - Signature: `fn slugify_relative (root : & Path , path : & Path) -> String { let relative = path . strip_prefix (root) . unwrap_or...`
  - Calls: unwrap_or, strip_prefix, join, collect, map, components, replace, to_string_lossy, as_os_str

