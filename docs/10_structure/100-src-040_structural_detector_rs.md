# Structure Group: src/040_structural_detector.rs

## File: src/040_structural_detector.rs

- Layer(s): 040_structural_detector.rs
- Language coverage: Rust (6)
- Element types: Function (3), Impl (1), Module (1), Struct (1)
- Total elements: 6

### Elements

- [Rust | Struct] `StructuralDetector` (line 0, pub)
  - Signature: `# [doc = " Structural invariant detector"] pub struct StructuralDetector { graph : DiGraph < String , () > , }`
- [Rust | Impl] `impl StructuralDetector { pub fn new (graph : DiGraph < String , () >) -> Self { Self { graph } } # [doc = " Build call graph from analysis result"] pub fn build_call_graph (analysis : & AnalysisResult) -> DiGraph < String , () > { let mut graph = DiGraph :: new () ; let mut node_map : HashMap < String , NodeIndex > = HashMap :: new () ; for element in & analysis . elements { if element . element_type == ElementType :: Function { let node = graph . add_node (element . name . clone ()) ; node_map . insert (element . name . clone () , node) ; } } for element in & analysis . elements { if element . element_type == ElementType :: Function { if let Some (& source) = node_map . get (& element . name) { for callee in & element . calls { if let Some (& target) = node_map . get (callee) { if source != target { graph . add_edge (source , target , ()) ; } } } } } } graph } # [doc = " Detect PROVEN structural invariants from analysis result's call graph"] pub fn detect_from_analysis (analysis : & AnalysisResult) -> Vec < Invariant > { let graph = Self :: build_call_graph (analysis) ; let detector = Self :: new (graph) ; let mut name_to_file : HashMap < String , String > = HashMap :: new () ; for element in & analysis . elements { if element . element_type == ElementType :: Function { name_to_file . insert (element . name . clone () , element . file_path . clone ()) ; } } let mut invariants = detector . detect_all () ; for inv in & mut invariants { if let Some (file_path) = name_to_file . get (& inv . target) { inv . file_path = file_path . clone () ; } } invariants } # [doc = " Detect all structural invariants"] pub fn detect_all (& self) -> Vec < Invariant > { let mut invariants = Vec :: new () ; invariants . extend (self . detect_layer_fixed ()) ; invariants . extend (self . detect_degree_stable ()) ; invariants . extend (self . detect_leaf_root ()) ; invariants . extend (self . detect_bridges ()) ; invariants . extend (self . detect_scc_membership ()) ; invariants } # [doc = " Detect layer-fixed invariants (PROVEN)"] # [doc = ""] # [doc = " Once a layer is assigned via the call graph, it's mathematically fixed"] fn detect_layer_fixed (& self) -> Vec < Invariant > { let mut invariants = Vec :: new () ; let layers = infer_layers (& self . graph , 100) ; for (name , layer_info) in layers { let inv = Invariant :: new (name . clone () , "" . to_string () , InvariantKind :: Structural (StructuralInvariant :: LayerFixed { layer : layer_info . layer , }) , InvariantStrength :: Proven , format ! ("Layer {} assignment is proven from call graph" , layer_info . layer) ,) ; invariants . push (inv) ; } invariants } # [doc = " Detect degree-stable invariants (PROVEN)"] # [doc = ""] # [doc = " In-degree and out-degree are structural properties"] fn detect_degree_stable (& self) -> Vec < Invariant > { let mut invariants = Vec :: new () ; for node_idx in self . graph . node_indices () { let name = self . graph [node_idx] . clone () ; let in_degree = self . graph . neighbors_directed (node_idx , Direction :: Incoming) . count () ; let out_degree = self . graph . neighbors_directed (node_idx , Direction :: Outgoing) . count () ; let mut inv = Invariant :: new (name . clone () , "" . to_string () , InvariantKind :: Structural (StructuralInvariant :: DegreeStable { in_degree , out_degree , }) , InvariantStrength :: Proven , format ! ("Degree: in={}, out={} (proven from graph)" , in_degree , out_degree) ,) ; inv . add_evidence (format ! ("In-degree: {}" , in_degree)) ; inv . add_evidence (format ! ("Out-degree: {}" , out_degree)) ; invariants . push (inv) ; } invariants } # [doc = " Detect leaf and root nodes (PROVEN)"] fn detect_leaf_root (& self) -> Vec < Invariant > { let mut invariants = Vec :: new () ; for node_idx in self . graph . node_indices () { let name = self . graph [node_idx] . clone () ; let in_degree = self . graph . neighbors_directed (node_idx , Direction :: Incoming) . count () ; let out_degree = self . graph . neighbors_directed (node_idx , Direction :: Outgoing) . count () ; if out_degree == 0 { let inv = Invariant :: new (name . clone () , "" . to_string () , InvariantKind :: Structural (StructuralInvariant :: Leaf) , InvariantStrength :: Proven , "Leaf node (calls no other functions)" . to_string () ,) ; invariants . push (inv) ; } if in_degree == 0 { let inv = Invariant :: new (name . clone () , "" . to_string () , InvariantKind :: Structural (StructuralInvariant :: Root) , InvariantStrength :: Proven , "Root node (called by no other functions)" . to_string () ,) ; invariants . push (inv) ; } } invariants } # [doc = " Detect bridges (PROVEN)"] # [doc = ""] # [doc = " A bridge is an edge whose removal disconnects the graph"] fn detect_bridges (& self) -> Vec < Invariant > { let mut invariants = Vec :: new () ; for node_idx in self . graph . node_indices () { let name = self . graph [node_idx] . clone () ; let in_degree = self . graph . neighbors_directed (node_idx , Direction :: Incoming) . count () ; let out_degree = self . graph . neighbors_directed (node_idx , Direction :: Outgoing) . count () ; if in_degree == 1 && out_degree == 1 { let inv = Invariant :: new (name . clone () , "" . to_string () , InvariantKind :: Structural (StructuralInvariant :: Bridge) , InvariantStrength :: Empirical { paths_checked : 1 } , "Potential bridge node in call graph" . to_string () ,) ; invariants . push (inv) ; } } invariants } # [doc = " Detect SCC membership (PROVEN)"] # [doc = ""] # [doc = " Membership in a strongly connected component is a proven structural property"] fn detect_scc_membership (& self) -> Vec < Invariant > { let mut invariants = Vec :: new () ; let compression = SccCompression :: new (self . graph . clone ()) ; for (scc_id , scc) in compression . sccs . iter () . enumerate () { for & node_idx in scc { let name = self . graph [node_idx] . clone () ; let inv = Invariant :: new (name . clone () , "" . to_string () , InvariantKind :: Structural (StructuralInvariant :: SccMembership { scc_id , scc_size : scc . len () , }) , InvariantStrength :: Proven , format ! ("Member of SCC {} (size: {})" , scc_id , scc . len ()) ,) ; invariants . push (inv) ; } } invariants } } . self_ty` (line 0, priv)
- [Rust | Function] `test_all_structural_invariants_proven` (line 0, priv)
  - Signature: `# [test] fn test_all_structural_invariants_proven () { let mut graph = DiGraph :: new () ; let a = graph . add_node (...`
  - Calls: DiGraph::new, add_node, to_string, add_node, to_string, add_edge, StructuralDetector::new, detect_all, count, filter, iter
- [Rust | Function] `test_detect_degree_stable` (line 0, priv)
  - Signature: `# [test] fn test_detect_degree_stable () { let mut graph = DiGraph :: new () ; let a = graph . add_node ("A" . to_str...`
  - Calls: DiGraph::new, add_node, to_string, add_node, to_string, add_edge, StructuralDetector::new, detect_degree_stable, unwrap, find, iter
- [Rust | Function] `test_detect_leaf_root` (line 0, priv)
  - Signature: `# [test] fn test_detect_leaf_root () { let mut graph = DiGraph :: new () ; let a = graph . add_node ("A" . to_string ...`
  - Calls: DiGraph::new, add_node, to_string, add_node, to_string, add_node, to_string, add_edge, add_edge, StructuralDetector::new, detect_leaf_root, collect, filter, iter, collect, filter, iter
- [Rust | Module] `tests` (line 0, priv)

