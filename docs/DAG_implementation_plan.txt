# Dead Code Analysis: Implementation Plan (DAG-Ordered)

## Dependency Graph

```
Layer 0 (Foundations):
    [A] Data Types
    [B] Attribute Parser
    [C] Doc Comment Parser

Layer 1 (Detection):
    [D] Call Graph Builder      (depends on A)
    [E] Intent Detector         (depends on A, B, C)
    [F] Test Boundary Detector  (depends on A)

Layer 2 (Classification):
    [G] Category Classifier     (depends on A, D, E, F)
    [H] Confidence Scorer       (depends on A, D, E, F, G)

Layer 3 (Action Planning):
    [I] Action Recommender      (depends on A, G, H)
    [J] JSON Report Generator   (depends on A, G, H, I)

Layer 4 (Integration):
    [K] Pipeline Filter         (depends on A, G)
    [L] CLI Interface           (depends on A, G, H, I, J)
    [M] Policy File Support     (depends on A, E)

Layer 5 (Validation):
    [N] Integration Tests       (depends on all)
```

## Implementation Order (Topological)

### Phase 1: Foundations (Layer 0)

**Task A: Data Types**
File: `src/200_dead_code_types.rs`
Dependencies: None
Estimated Lines: 150

Data structures:
```rust
pub enum DeadCodeCategory {
    Unreachable,          // U
    ReachableUnused,      // R
    TestOnly,             // T
    LatentPlanned,        // H
}

pub enum ConfidenceLevel {
    CallGraph,
    TestReference,
    IntentTag,
    Heuristic,
}

pub enum RecommendedAction {
    DeleteSafe,
    Quarantine,
    RelocateTests,
    Keep,
    ManualReview,
}

pub struct DeadCodeItem {
    pub symbol: String,
    pub file: PathBuf,
    pub line: usize,
    pub category: DeadCodeCategory,
    pub confidence: ConfidenceLevel,
    pub action: RecommendedAction,
    pub reason: String,
}

pub struct DeadCodeReport {
    pub summary: DeadCodeSummary,
    pub items: Vec<DeadCodeItem>,
}

pub struct DeadCodeSummary {
    pub unreachable: usize,
    pub reachable_unused: usize,
    pub test_only: usize,
    pub latent_planned: usize,
}
```

**Task B: Attribute Parser**
File: `src/201_attribute_parser.rs`
Dependencies: A
Estimated Lines: 100

Functions:
- `parse_mmsb_latent_attr(file: &Path) -> HashMap<String, IntentMetadata>`
- `extract_attribute_value(attr: &syn::Attribute, key: &str) -> Option<String>`
- `scan_file_attributes(path: &Path) -> Vec<IntentTag>`

**Task C: Doc Comment Parser**
File: `src/202_doc_comment_parser.rs`
Dependencies: A
Estimated Lines: 80

Functions:
- `scan_doc_comments(file: &Path) -> HashMap<String, Vec<IntentMarker>>`
- `detect_latent_markers(comment: &str) -> Option<IntentMarker>`
- Patterns: `@latent`, `@planned`, `@future`, `@deprecated-planned`

---

### Phase 2: Detection (Layer 1)

**Task D: Call Graph Builder**
File: `src/203_call_graph_builder.rs`
Dependencies: A
Estimated Lines: 200

Functions:
- `build_call_graph(elements: &[CodeElement]) -> CallGraph`
- `compute_reachability(graph: &CallGraph, entrypoints: &[String]) -> HashSet<String>`
- `find_entrypoints(elements: &[CodeElement]) -> Vec<String>`
- Entrypoint detection: `main`, `#[test]`, `pub fn`, exported symbols

**Task E: Intent Detector**
File: `src/204_intent_detector.rs`
Dependencies: A, B, C
Estimated Lines: 120

Functions:
- `detect_intent_signals(file: &Path) -> HashMap<String, IntentSignal>`
- `check_planned_directory(path: &Path, policy: &Policy) -> bool`
- `merge_intent_sources(attrs: IntentMap, docs: IntentMap, dir: DirPolicy) -> IntentMap`

**Task F: Test Boundary Detector**
File: `src/205_test_boundary_detector.rs`
Dependencies: A
Estimated Lines: 100

Functions:
- `detect_test_modules(file: &Path) -> HashSet<String>`
- `is_cfg_test_item(item: &syn::Item) -> bool`
- `find_test_callers(symbol: &str, call_graph: &CallGraph) -> Vec<String>`

---

### Phase 3: Classification (Layer 2)

**Task G: Category Classifier**
File: `src/206_category_classifier.rs`
Dependencies: A, D, E, F
Estimated Lines: 150

Core logic:
```rust
pub fn classify_symbol(
    symbol: &str,
    call_graph: &CallGraph,
    intent_map: &IntentMap,
    test_boundaries: &TestBoundaries,
) -> DeadCodeCategory {
    // Priority order:
    // 1. Check intent signals (highest priority)
    if intent_map.contains_key(symbol) {
        return DeadCodeCategory::LatentPlanned;
    }
    
    // 2. Check test-only usage
    if is_test_only(symbol, call_graph, test_boundaries) {
        return DeadCodeCategory::TestOnly;
    }
    
    // 3. Check reachability
    if !is_reachable(symbol, call_graph) {
        return DeadCodeCategory::Unreachable;
    }
    
    // 4. Reachable but never executed (requires coverage)
    DeadCodeCategory::ReachableUnused
}
```

**Task H: Confidence Scorer**
File: `src/207_confidence_scorer.rs`
Dependencies: A, D, E, F, G
Estimated Lines: 80

Functions:
- `assign_confidence(item: &DeadCodeItem, evidence: &Evidence) -> ConfidenceLevel`
- Scoring rules:
  - `IntentTag` if explicit attribute/doc marker
  - `CallGraph` if topologically proven unreachable
  - `TestReference` if all callers in test modules
  - `Heuristic` otherwise

---

### Phase 4: Action Planning (Layer 3)

**Task I: Action Recommender**
File: `src/208_action_recommender.rs`
Dependencies: A, G, H
Estimated Lines: 100

Decision tree:
```rust
pub fn recommend_action(
    category: DeadCodeCategory,
    confidence: ConfidenceLevel,
) -> RecommendedAction {
    match (category, confidence) {
        (Unreachable, CallGraph) => DeleteSafe,
        (Unreachable, _) => ManualReview,
        (ReachableUnused, _) => Quarantine,
        (TestOnly, _) => RelocateTests,
        (LatentPlanned, _) => Keep,
    }
}
```

**Task J: JSON Report Generator**
File: `src/209_json_report_generator.rs`
Dependencies: A, G, H, I
Estimated Lines: 120

Output format:
```json
{
  "timestamp": "2025-12-30T23:00:00Z",
  "summary": {
    "unreachable": 42,
    "reachable_unused": 17,
    "test_only": 8,
    "latent_planned": 12,
    "total_analyzed": 1543
  },
  "items": [
    {
      "symbol": "unused_helper",
      "file": "src/utils.rs",
      "line": 245,
      "category": "unreachable",
      "confidence": "call_graph",
      "recommended_action": "delete_safe",
      "reason": "No callers in call graph; not exported; not in tests"
    }
  ],
  "metadata": {
    "analyzer_version": "0.1.0",
    "project_root": "/path/to/project",
    "entrypoints_found": 15
  }
}
```

---

### Phase 5: Integration (Layer 4)

**Task K: Pipeline Filter**
File: `src/210_pipeline_filter.rs`
Dependencies: A, G
Estimated Lines: 60

Functions:
- `filter_dead_code(elements: &[CodeElement], report: &DeadCodeReport) -> Vec<CodeElement>`
- `should_exclude_from_analysis(symbol: &str, category: DeadCodeCategory) -> bool`
- Integration points:
  - Cohesion analyzer input filter
  - Cluster extraction input filter
  - Layer enforcement input filter

**Task L: CLI Interface**
File: `src/211_dead_code_cli.rs`
Dependencies: A, G, H, I, J
Estimated Lines: 100

CLI flags:
```
--dead-code              Run dead code analysis
--dead-code-json <path>  Export JSON report to path
--dead-code-filter       Filter dead code from main analysis
--dead-code-apply        Auto-delete items marked delete_safe (dangerous)
```

Integration with `070_layer_utilities.rs`:
```rust
#[arg(long)]
dead_code: bool,

#[arg(long)]
dead_code_json: Option<PathBuf>,

#[arg(long)]
dead_code_filter: bool,
```

**Task M: Policy File Support**
File: `src/212_dead_code_policy.rs`
Dependencies: A, E
Estimated Lines: 80

Policy file format (`docs/dead_code_policy.toml`):
```toml
[intent_directories]
planned = ["src/planned", "src/experimental"]
protected = ["src/core", "src/public_api"]

[aging_rules]
quarantine_days = 90
warning_days = 30

[protection_scopes]
prefixes = ["public_", "api_"]
suffixes = ["_interface", "_contract"]
```

---

### Phase 6: Validation (Layer 5)

**Task N: Integration Tests**
File: `test/dead_code_test.rs`
Dependencies: All
Estimated Lines: 300

Test cases:
1. **Intent preservation test**:
   - Code with `#[mmsb_latent]` → category = LatentPlanned
   - Code with `@latent` doc comment → category = LatentPlanned
   - Code in `src/planned/` → category = LatentPlanned

2. **Unreachable detection test**:
   - Function with no callers → category = Unreachable
   - Function called only by unreachable → category = Unreachable
   - Public function exported → NOT Unreachable

3. **Test-only detection test**:
   - Function in `#[cfg(test)]` module → category = TestOnly
   - Function called only by `#[test]` functions → category = TestOnly
   - Test helper in production file → category = TestOnly

4. **Confidence test**:
   - Topologically proven unreachable → confidence = CallGraph
   - Attribute-tagged latent → confidence = IntentTag
   - Orphaned heuristic → confidence = Heuristic

5. **Pipeline isolation test**:
   - Verify dead code excluded from cohesion analysis
   - Verify dead code excluded from cluster extraction
   - Verify dead code excluded from layer enforcement

6. **JSON output test**:
   - Validate schema compliance
   - Verify summary counts match items
   - Test machine parseability

---

## Implementation Schedule

**Week 1**: Phase 1 (A, B, C)
**Week 2**: Phase 2 (D, E, F)
**Week 3**: Phase 3 (G, H)
**Week 4**: Phase 4 (I, J)
**Week 5**: Phase 5 (K, L, M)
**Week 6**: Phase 6 (N) + Integration

Total estimated lines: ~1,840
Total estimated time: 6 weeks

---

## Critical Path

```
A → D → G → I → J → L → N
    ↓   ↓   ↓
A → E → G → K → N
    ↓   ↓
A → F → G
```

Longest path: A → D → G → I → J → L → N (7 tasks)

---

## Risk Mitigation

1. **Intent detection accuracy**:
   - Risk: False negatives destroy latent code
   - Mitigation: Conservative defaults; manual review for Unreachable
   - Validation: Test with known latent functions

2. **Call graph completeness**:
   - Risk: Indirect calls via traits/closures missed
   - Mitigation: Trait impl scanning; closure capture analysis
   - Validation: Compare with cargo-unused output

3. **Test boundary accuracy**:
   - Risk: Test helpers misclassified as production code
   - Mitigation: Scan for `#[test]`, `#[cfg(test)]`, `tests/` directory
   - Validation: Manual review of TestOnly category

4. **Pipeline contamination**:
   - Risk: Downstream analysis still uses dead code
   - Mitigation: Explicit filter gates in each analyzer
   - Validation: Verify metrics unchanged with/without filter

---

## Success Criteria

1. ✅ 100% of code with intent tags → LatentPlanned category
2. ✅ 0% false positives in DeleteSafe recommendations
3. ✅ JSON output validates against schema
4. ✅ Dead code excluded from cohesion/cluster/layer analysis
5. ✅ CLI flags functional and documented
6. ✅ Policy file parsing works correctly
7. ✅ Integration tests pass at 100%

---

## File Count Summary

New files created: 14
- 3 foundation files (200-202)
- 3 detection files (203-205)
- 2 classification files (206-207)
- 2 action planning files (208-209)
- 3 integration files (210-212)
- 1 test file

Modified files: 3
- `src/070_layer_utilities.rs` (CLI flags)
- `src/190_main.rs` (module imports)
- `src/200_lib.rs` (public exports)

---

## Post-Implementation Tasks

1. Update `docs/Requirements.txt` to mark FR10.* as [x]
2. Add dead code section to `docs/conscience_map.md`
3. Create example policy file in `docs/dead_code_policy.toml`
4. Document CLI usage in README
5. Add dead code report to xtask workflows
6. Integrate with CI/CD for automated checks

